[{"categories":["Hugo"],"contents":"https://github.com/hugo-toha/hugo-toha.github.io\nhttps://toha-guides.netlify.app/\nhttps://github.com/hugo-toha/guides\nCreating Sub Category https://toha-guides.netlify.app/posts/writing-posts/organizing/sub-category/example/\n","date":"January 1, 2025","hero":"/posts/hugo/hero.gif","permalink":"https://codex-devlab.github.io/posts/hugo/","summary":"\u003cp\u003e\u003ca href=\"https://github.com/hugo-toha/hugo-toha.github.io\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/hugo-toha/hugo-toha.github.io\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://toha-guides.netlify.app/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://toha-guides.netlify.app/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/hugo-toha/guides\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/hugo-toha/guides\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"creating-sub-category\"\u003eCreating Sub Category\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://toha-guides.netlify.app/posts/writing-posts/organizing/sub-category/example/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://toha-guides.netlify.app/posts/writing-posts/organizing/sub-category/example/\u003c/a\u003e\u003c/p\u003e","tags":["Hugo","Hugo-toha","Manual"],"title":"Hugo"},{"categories":["study"],"contents":"Algorithms Algospot Problem\nBackjoon Problem \u0026mdash;backjoon 문제모음\n단계별 문제풀이(backjoon Level) 알고리즘 분류별 문제풀이 \u0026ndash;Algorithms Categories Personal Problem\nData Structure\nCoding Tip\nGit 끝내기 Linux etc \u0026mdash;etc\u0026hellip;setiing and installation jekyll \u0026mdash;Jekyll for blog ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://codex-devlab.github.io/posts/study/sub-algorithms/backjoon/","summary":"\u003ch2 id=\"algorithms\"\u003e\u003ca href=\"/tag/algorithms/\"\u003eAlgorithms\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"/category/algospot/\"\u003eAlgospot Problem\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"/category/backjoon-category/\"\u003eBackjoon Problem\u003c/a\u003e \u0026mdash;backjoon 문제모음\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/tag/backjoon-level/\"\u003e단계별 문제풀이\u003c/a\u003e(backjoon Level)\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/tag/backjoon-classification/\"\u003e알고리즘 분류별 문제풀이\u003c/a\u003e \u0026ndash;Algorithms Categories\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"../_featured_categories/personalcode/personalcode.md\"\u003ePersonal Problem\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"/tag/datastructure/\"\u003eData Structure\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"/tag/coding-tip/\"\u003eCoding Tip\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"git-끝내기\"\u003e\u003ca href=\"/tag/git/\"\u003eGit 끝내기\u003c/a\u003e\u003c/h2\u003e\n\u003ch2 id=\"linux\"\u003e\u003ca href=\"/category/linux/\"\u003eLinux\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/tag/etc/\"\u003eetc\u003c/a\u003e \u0026mdash;etc\u0026hellip;setiing and installation\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/tag/jekyll/\"\u003ejekyll\u003c/a\u003e \u0026mdash;Jekyll for blog\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv style=\"margin-top: rem;\"\u003e\u003c/div\u003e","tags":["Algorithms","Backjoon","Online Judge"],"title":"Algorithms Problems"},{"categories":null,"contents":"Scanf 에서 공백과 \\n의 의미 먼저 IBM에서 제공하는 Scanf의 정의먼저 보겠습니다.\n공백 문자로,isspace()함수(줄 바꾸기 문자와 공백과 같은)에서 지정됩니다.\n공백 문자로 scanf함수는 공백이 아닌 다음 문자까지 입력의 모든 연속 공백 문자를 읽지만 저장하지 않습니다. format-string의 한 공백 문자는 입력에서 공백 문자의 조합과 일치합니다.\n퍼센트 기호 문자(%)를 제외하고, 공백이 아닌 문자입니다.\n공백이 아닌 문자로scanf()함수는 일치하는 공백이 아닌 문자를 읽지만 저장하지 않습니다.\nstdin의 다음 문자가 일치하지 않는 경우,scanf()함수가 종료합니다.\n예제 #include \u0026lt;stdio.h\u0026gt; int main(){ int a,b; scanf(\u0026#34;%d \u0026#34;,\u0026amp;a); printf(\u0026#34;%d\\n\u0026#34;,a); scanf(\u0026#34;%d \u0026#34;,\u0026amp;b); printf(\u0026#34;%d\\n\u0026#34;,b); } $ ./a.out 1 1 2 2 우리가 1을 입력후 엔터를 치면 1이 출력되고 그다음 2를 입력하면 2가 출력 될것이라고 예상할것이다.\n$ ./a.out 1 2 1 q 2 하지만 1을 입력후 2를 입력해야 1이 출력되고 q를 입력하자 2가 출력된다 왜일까?\nscanf(\u0026quot;%d \u0026ldquo;,\u0026amp;a) 를 해석해 보자 %d뒤에 공백이 있는데, 이 부분에서\n숫자, 1자 이상의 공백문자, 공백문자가 아닌 문자값이 들어오기를 기다립니다.\n그렇다면 1을 입력후에는 버퍼안에 1이 들어가있고\n그다음 공백 문자 이외의 문자를 기다립니다.\n물론 우리는 엔터를 통해 \u0026lsquo;\\n\u0026rsquo;을 입력했지만 New line은 문자로 할당되지 않습니다.\n그리고 다음 기대 값인 2를 입력 했을때 비로소 공백이 아닌 문자가 들어오게 된것이죠.\n그래서 버퍼에있던 1을 출력해 주고 현재 버퍼엔 2가 남아있게 됩니다.\n그리고 아무 문자를 입력하고 나면 공백이아닌 문자가 들어왔기 때문에\n2가 출력되게 되는것입니다.\n그리고 프로그램이 끝나기 전까지는 버퍼에 마지막 입력했던 문자가 들어있겠지요.\n참고 IBM Scanf 정의 여기 참고\n","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://codex-devlab.github.io/posts/study/sub-algorithms/programming-tips/the-meaning-of-scanf-in-c-language/","summary":"\u003ch2 id=\"scanf-에서-공백과-n의-의미\"\u003eScanf 에서 공백과 \\n의 의미\u003c/h2\u003e\n\u003cp\u003e먼저 IBM에서 제공하는 Scanf의 정의먼저 보겠습니다.\u003c/p\u003e\n\u003cp\u003e공백 문자로,\u003ca href=\"https://www.ibm.com/support/knowledgecenter/ko/ssw_ibm_i_73/rtref/isalnum.htm?view=kc#isalnum\" target=\"_blank\" rel=\"noopener\"\u003eisspace()함수\u003c/a\u003e(줄 바꾸기 문자와 공백과 같은)에서 지정됩니다.\u003c/p\u003e\n\u003cp\u003e공백 문자로 \u003ccode\u003escanf\u003c/code\u003e함수는 공백이 아닌 다음 문자까지 입력의 모든 연속 공백 문자를 읽지만 저장하지 않습니다. format-string의 한 공백 문자는 입력에서 공백 문자의 조합과 일치합니다.\u003c/p\u003e\n\u003cp\u003e퍼센트 기호 문자(%)를 제외하고, 공백이 아닌 문자입니다.\u003c/p\u003e\n\u003cp\u003e공백이 아닌 문자로scanf()함수는 일치하는 공백이 아닌 문자를 읽지만 저장하지 않습니다.\u003c/p\u003e\n\u003cp\u003estdin의 다음 문자가 일치하지 않는 경우,scanf()함수가 종료합니다.\u003c/p\u003e\n\u003ch2 id=\"예제\"\u003e예제\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e(){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a,b;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d \u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ea);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e,a);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003escanf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d \u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eb);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e,b); }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ ./a.out\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e우리가 1을 입력후 엔터를 치면 1이 출력되고 그다음 2를 입력하면 2가 출력 될것이라고 예상할것이다.\u003c/p\u003e","tags":["Study","Programming tips","C","Scanf"],"title":"C언어 Scanf 의 의미"},{"categories":["study"],"contents":"Algorithms Algospot Problem\nBackjoon Problem \u0026mdash;backjoon 문제모음\n단계별 문제풀이(backjoon Level) 알고리즘 분류별 문제풀이 \u0026ndash;Algorithms Categories Personal Problem \u0026mdash;personal code\n{:.related-posts.faded}\nData Structure \u0026mdash;C로 구현한 자료구조\nCoding Tip \u0026mdash;C Coding에 대한 고찰\nGit 끝내기 Linux etc \u0026mdash;etc\u0026hellip;setiing and installation jekyll \u0026mdash;Jekyll for blog ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://codex-devlab.github.io/posts/study/sub-algorithms/data-structure/","summary":"\u003ch2 id=\"algorithms\"\u003e\u003ca href=\"/tag/algorithms/\"\u003eAlgorithms\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"/category/algospot/\"\u003eAlgospot Problem\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"/category/backjoon-category/\"\u003eBackjoon Problem\u003c/a\u003e \u0026mdash;backjoon 문제모음\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/tag/backjoon-level/\"\u003e단계별 문제풀이\u003c/a\u003e(backjoon Level)\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/tag/backjoon-classification/\"\u003e알고리즘 분류별 문제풀이\u003c/a\u003e \u0026ndash;Algorithms Categories\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"../_featured_categories/personalcode/personalcode.md\"\u003ePersonal Problem\u003c/a\u003e  \u0026mdash;personal code\u003c/p\u003e\n\u003cp\u003e{:.related-posts.faded}\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"/tag/datastructure/\"\u003eData Structure\u003c/a\u003e  \u0026mdash;C로 구현한 자료구조\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"/tag/c-coding-tip/\"\u003eCoding Tip\u003c/a\u003e  \u0026mdash;C Coding에 대한 고찰\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"git-끝내기\"\u003e\u003ca href=\"/tag/git/\"\u003eGit 끝내기\u003c/a\u003e\u003c/h2\u003e\n\u003ch2 id=\"linux\"\u003e\u003ca href=\"/category/linux/\"\u003eLinux\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/tag/etc/\"\u003eetc\u003c/a\u003e \u0026mdash;etc\u0026hellip;setiing and installation\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/tag/jekyll/\"\u003ejekyll\u003c/a\u003e \u0026mdash;Jekyll for blog\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv style=\"margin-top: rem;\"\u003e\u003c/div\u003e","tags":["Algorithms","Study","Data Struture"],"title":"Data Structure"},{"categories":null,"contents":"FTW() 란? ftw함수는 해당 경로안의 모든 디렉토리들을 탐색하여 보여준다.\nSYNOPSIS #include \u0026lt;ftw.h\u0026gt;\nint ftw(const char *path, int (*fn)(const char *, const struct sta *ptr, int flag),int depth);\nint nftw(const char *path, int (*fn)(const char *, const struct stat *ptr, int flag, struct FTW *), int depth, int flags);\nftw는 path, fn, depth의 3가지 인자가 필요하다.\npath : 탐색될 대상이 되는 경로.\nfn : 탐색중 발견된 파일의 정보를 받는 콜백 포인터.\ndepth : 탐색중 몇개의 하위디렉토리를 탐색할것인지 설정.\nreturn : 성공하면 0, 실패하면 0이외의 값, 에러가 검출되면 -1리턴\n=\u0026gt;(C에서는 리턴값에 대한 정확한 이해가 필요합니다. 성공시 0을 리턴하며 실패시 0이외의 값을 리턴합니다.)\nDescription FTW_F A regular file.\nFTW_D A directory being visited in pre-order.\nFTW_DNR A directory which cannot be read. The directory will not be descended into.\nFTW_DP A directory being visited in post-order (nftw() only).\nFTW_NS A file for which no stat(2) information was available. The contents of the stat structure are undefined.\nFTW_SL A symbolic link.\nFTW_SLN A symbolic link with a non-existent target (nftw() only)\nSource Code /*authored by Edward Son * * 20161103 * */ #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void Myftw(char* path){ DIR *dirptr; //탐색할 경로를 담을 디렉토리포인터 struct dirent *dir; //디렉토리의 정보를 읽어올 포인터 struct stat file_att; //디렉토리와 파일의 정보를 읽어올 구조체 int i; //이것도 nuff해 보시지! char nuff[255]=\u0026#34; \u0026#34;; char space[]=\u0026#34;-----\u0026gt;\u0026#34;; static int num =0; //opendir 로 포인터 개방 if((dirptr = opendir(path))==NULL){ printf(\u0026#34;NO Such a directory\u0026#34;); return; // Base step for Recursive call } if(chdir(path)\u0026lt;0){ perror(\u0026#34;No such path\u0026#34;); exit(1); } while((dir=readdir(dirptr))!=NULL){ stat(dir -\u0026gt; d_name, \u0026amp;file_att); getcwd(nuff,1024); if(strcmp(\u0026#34;.\u0026#34;,dir-\u0026gt;d_name)==0||strcmp(\u0026#34;..\u0026#34;,dir-\u0026gt;d_name)==0) continue; //현재 경로안에 파일들 출력 if(S_ISREG(file_att.st_mode)){ printf(\u0026#34;Path : %s \\n\u0026#34;,nuff); if(num==1){ printf(\u0026#34;file : %s %s\\n\u0026#34;,space,dir-\u0026gt;d_name); } else{ printf(\u0026#34;file : %s\\n\u0026#34;,dir-\u0026gt;d_name); } } //하위 디렉토리가 있을때 해당 디렉토리로 이동 else if(S_ISDIR(file_att.st_mode)){ //디렉토리 인지 확인 printf(\u0026#34;Path : %s \\n\u0026#34;,nuff); if(dir-\u0026gt;d_ino !=0){ //디렉토리 안의 i_node #를 확인하여 순서대로 포인터 이동 printf(\u0026#34;directory : %s %s\\n\u0026#34;,space,dir-\u0026gt;d_name); } num++; Myftw(dir-\u0026gt;d_name); num=0; } } chdir(\u0026#34;..\u0026#34;); printf(\u0026#34;************************\\n\u0026#34;); } int main(int argc, char** argv){ if(argv[1]\u0026lt;0){ perror(\u0026#34;Not exist\u0026#34;); exit(1); } else Myftw(argv[1]); } Result 공부한지 얼마 안되어서 코딩실력이 많이 부족합니다. 어떤 의견이든 코드에 대해 수정할 부분이나 추가 의견 있으시면 댓글로 달아주세요~\n","date":"August 10, 2018","hero":"/images/default-hero.jpg","permalink":"https://codex-devlab.github.io/posts/study/sub-computer-science/system-programming-ftw-implementation/","summary":"\u003ch2 id=\"ftw-란\"\u003eFTW() 란?\u003c/h2\u003e\n\u003cp\u003eftw함수는 해당 경로안의 모든 디렉토리들을 탐색하여 보여준다.\u003c/p\u003e\n\u003ch2 id=\"synopsis\"\u003eSYNOPSIS\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e#include \u0026lt;ftw.h\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eint ftw(const char *path, int (*fn)(const char *, const struct sta *ptr, int flag),int depth);\u003c/p\u003e\n\u003cp\u003eint nftw(const char *path, int (*fn)(const char *, const struct stat *ptr, int flag, struct FTW *), int depth, int flags);\u003c/p\u003e\n\u003cp\u003eftw는 path, fn, depth의 3가지 인자가 필요하다.\u003c/p\u003e\n\u003cp\u003epath : 탐색될 대상이 되는 경로.\u003c/p\u003e\n\u003cp\u003efn : 탐색중 발견된 파일의 정보를 받는 콜백 포인터.\u003c/p\u003e","tags":["Study","System-Programming","C"],"title":"시스템프로그래밍 FTW 구현"},{"categories":null,"contents":"C언어 프로그램이란? 컴퓨터에서 실행될때 특정 작업을 수행 하는 일련의 명령어들의 모음이다.\n소프트웨어 공학 요구사항 분석 자료형 정의 등등 Flow chart 설계 및 구현(pseudo code) 코드 구현 실행 테스트 유지보수 CPU 구조 Control unit\u0026lt;-\u0026gt;ALU\u0026lt;-\u0026gt;Processor resister(R1,R2,R3\u0026hellip;) 위의 3가지 장치들이 Internal bus로 연결되어 통신한다.\nALU(Arithmetic logic unit )\n산술 논리 장치 : 실질적으로 산술, 논리 계산을 수행함.\nResister\nCPU의 자체적인 메모리저장 기능.\nMemory buffer register(MBR)\n​\tI/O로 보내지거나 메모리에 저장될 Word 혹은 I/O나 메모리로 부터 Word를 받는 것.\nMemory address register(MAR)\nInstruction register(IR)\nInstruction buffer register(IBR)\nProgram counter(PC)\nAccumulator (AC) and mutiplier quotient (MQ)\nControl unit\nCPU의 명령어를 제어한다.\n폰노이만 구조(최초의 컴퓨터 구조를 만듬) 폰노이만의 구조는 CPU, 메모리, 프로그램 구조를 갖는 프로그램 내장 방식 컴퓨터를 뜻한다.\n{: .center-image}\n폰노이만 구조(출처: 위키 백과사전) C 메모리 구조 {: width=\u0026ldquo;50%\u0026rdquo; height=\u0026ldquo;50%\u0026rdquo;}(출처 : https://bitsofcomputer.blogspot.com/)\nc언어에서의 메모리 구조를 알고 있다는것은 상당히 중요하다.\n주로 동적 할당 할때나 임베디드 시스템을 다룰때 메모리 구조와 영역을 알고 있으면 편하다.\nlocal variables can be stored either on the stack or in a data segment depending on whether they are auto or static. (if neither auto or static is explicitly specified, auto is assumed)\nglobal variables are stored in a data segment (unless the compiler can optimize them away, see const) and have visibility from the point of declaration to the end of the compilation unit.\nstatic variables are stored in a data segment (again, unless the compiler can optimize them away) and have visibility from the point of declaration to the end of the enclosing scope. Global variables which are not static are also visible in other compilation units (see extern).\nauto variables are always local and are stored on the stack.\nthe register modifier tells the compiler to do its best to keep the variable in a register if at all possible. Otherwise it is stored on the stack.\nextern variables are stored in the data segment. The extern modifier tells the compiler that a different compilation unit is actually declaring the variable, so don\u0026rsquo;t create another instance of it or there will be a name collision at link time.\nconst variables can be stored either on the stack or a readonly data segment depending on whether they are auto or static. However, if the compiler can determine that they cannot be referenced from a different compilation unit, or that your code is not using the address of the const variable, it is free to optimize it away (each reference can be replaced by the constant value). In that case it\u0026rsquo;s not stored anywhere.\nthe volatile modifier tells the compiler that the value of a variable may change at anytime from external influences (usually hardware) so it should not try to optimize away any reloads from memory into a register when that variable is referenced. This implies static storage.\ngeeks를 참고 하면서 공부해보자\nStorage class in C\n컴파일 과정 gcc compiler\nsource.c \u0026mdash;\u0026mdash;-\u0026gt; source.i \u0026mdash;\u0026mdash;-\u0026gt; source.s \u0026mdash;\u0026mdash;-\u0026gt; source.o \u0026mdash;\u0026mdash;-\u0026gt; source\n​ (precompile) (compiler) (assembler) (linker)\ngcc compile 과정 (출처: 제타위키) $ gcc test.c $ ls a.out 실행 파일 생성 $ gcc -c test.c test.o 오브젝트 파일 생성 $ gcc -o test.out test.o test.out 실행 파일이 생성됨 $ gcc -v --save-temps -o test.out test.c 컴파일 전체 과정을 보여주고 파일을 저장해줌 test.c test.i test.s test.o test.out C Concept 일단 이부분은 ISO/IEC 9899:TC3 의 표준을 보고 작성하였다.\nscope scope에 자세히 들어가기 전에 먼저 선행되야 하는 개념이있다.\nint i=0; 선언자 식별자 코딩을 하면서 int i 정수형 변수 선언은 그냥 자연스레 넘어갔었다.\n하지만 scope를 이해하기 위해서 더욱 자세하게 파고들어 보자.\n두가지 개념을 살펴보자.\nDeclarator 선언자 라고 하며, Type declarator라고도 한다.\n선언자의 역할은 변수의 형을 지정 하는것이다.\n위의 예제에 적용해 보자면 int 는 정수형 선언자 이다.\nIdentifier 식별자 라고하며, 형선언자로 인해 특정 데이터 형을 가질수 있는 변수가 된다.\nint 는 Type sepcifier(형식 지정자) 라고 한다.\n즉, i 는 int 형 변수에 대한 식별자이다.\n하지만 식별자는 반드시 변수에만 해당하는 것은 아니다.\n예를 들어 void main main은 void형 함수에 대한 식별자 이며,\nprintf() 는 printf 함수에 대한 식별자 이다.\nVisible 식별자는 오직 자신이 존재 하는 scope안에서만 사용될수 있다.\nInner Scope , Outer Scope의 개념을 이해 하는게 편할것 같다.\n예제를 살펴 보자.\n#include \u0026lt;stdio.h\u0026gt; int glo=10; void main(){ //scope 1 int a=3; { //scope 2 int b=4; { //scope 3 int c=8; printf(\u0026#34;a: %d b: %d c: %d glo: %d\\n\u0026#34;,a,b,c,glo ); } printf(\u0026#34;a: %d b: %d c: %d glo: %d\\n\u0026#34;,a,b,c,glo ); } printf(\u0026#34;a: %d b: %d c: %d glo: %d\\n\u0026#34;,a,b,c,glo ); } 이제 결과를 예상해 보자. 여태 배운 대로 라면 Inner scope 에서 선언된 식별자는\nouter scope에서 사용할수 없다. 그렇다면 scope 2 에서는 scope3 의 정수형 식별자\nc를 사용할수 없고, scope 1 에서는 정수형 식별자 b,c를 사용할수 없다.\n그럼 결과를 보자.\ntest.c:12:48: error: use of undeclared identifier \u0026#39;c\u0026#39; printf(\u0026#34;a: %d b: %d c: %d glo: %d\\n\u0026#34;,a,b,c,glo ); ^ test.c:14:42: error: use of undeclared identifier \u0026#39;b\u0026#39; printf(\u0026#34;a: %d b: %d c: %d glo: %d\\n\u0026#34;,a,b,c,glo ); ^ test.c:14:44: error: use of undeclared identifier \u0026#39;c\u0026#39; printf(\u0026#34;a: %d b: %d c: %d glo: %d\\n\u0026#34;,a,b,c,glo ); 당연히 outer scope에서 inner scope의 식별자를 사용하는것은 불가능하다.\n때문에 scope 2 에서는 scope 3 의 식별자를 사용할수 없고,\nscope 1 에서는 scope 2, scope 3 의 식별자를 사용할수 없다.\nC99 표준에 서는 Scope 에 대해 다음과 같이 정의하고 있다.\nIf so, the scope of one entity (the inner scope) will be a strict subset of the scope of the other entity (the outer scope).\nWithin the inner scope, the identifier designates the entity declared in the inner scope; the entity declared in the outer scope is hidden (and not visible) within the inner scope.\nValid scope 같은 이름과 형식(Same entities)의 식별자 들은 다른 scope에서 사용되거나,\n다른 파일(Different name space)에서 사용되어야 한다.\nVariety of Identifier 각 종류의 식별자는 그 자체의 scope를 가진다.\nfunction : 함수 내부에서의 식별자 function은 자체의 code block {} 안에서 선언된 식별자는\n해당 scope안에서만 사용될수 있으며, global, static 의 속성이 없으면,\n해당 scope 밖의 식별자를 사용할수 없다.\nfunction prototype : 함수 선언 parameter에서의 식별자 예를 들어 fuction을 선언 하고 사용 하기 위해선\n전처리 부분에 function에 대한 정보를 알려줘야 한다.\n예제를 보자\n#include \u0026lt;stdio.h\u0026gt; int add(int a,int b); // Function prototype int main(){ int a=1; printf(\u0026#34;%d\\n\u0026#34;,add(a,a)); } int add(int a, int b){ return a+b; } function prototype 안에서의 int a와 main함수 scope안의 int a 는\n중복 되지만 문제 되지 않는 이유는, 서로 다른 inner scope이기 때문에\n서로 영향을 주지 않는다.\nfile : 서로 다른 파일내부의 식별자 block : code block내의 식별자 file scope 와 block 은 다음 예제를 보고 이해해 보자.\n//In add.c #include \u0026lt;stdio.h\u0026gt; extern int test; int add(int a,int b); // Function prototype void main() //main도 main함수의 식별자 이다. { int i=1; //main 함수 code block안에 있는 정수형 식별자 i이다. // 즉 main function 안에 존재 하는 정수형 식별자 이다. int result=0; { // code block int b=10; printf(\u0026#34;i+b: %d\\n\u0026#34;,i+b); } result = add(i,i); //add도 add함수의 식별자 이름이다. printf(\u0026#34;%d\u0026#34;,result); //printf 도 printf함수의 식별자 printf(\u0026#34;%d\u0026#34;,test); } int add(int a, int b){ // add function내부에서 사용하는 함수 a,b 이다. return a+b; } //In sub.c //sub.c로 건너 오면 같은 이름의 식별자도 다른 name space에 존재하기 때문에 // 서로 영향을 주지 안는다. #include \u0026lt;stdio.h\u0026gt; static int result =0; //여기에 왜 static을 붙였을까? int test=100; int sub(int a,int b); void main() { int i=1; // add.c를 벗어난 다른 name space에서 사용된 같은 이름의 식별자이다. result = sub(i,i); printf(\u0026#34;%d\u0026#34;,result); } int add(int a, int b){ return a-b; } 위의 코드를 살펴 보면 특이 부분이 있다.\nstatic add.c 와 sub.c의 전역 변수중에 이름이 같은게 있다.\n두변수의 이름은 모두 result 이다. 하지만 해당 코드들은 실행시 에러가 발생하지 않는다.\n왜일까?\n예상 대로 라면 같은 이름의 전역변수는 data segment에서 충돌될것이다.\n하지만 전역변수에 staitc을 붙여 주면, 해당 전역 변수는\n해당 파일의 file scope를 벗어나지 못한다.\n때문에 sub.c의 result 는 sub file의 file scope 가 끝남과 동시에\n메모리에서 해제 된다.\nextern add.c 를 보면 extern int test 를 하고 있다.\n뭘까? test 식별자는 add.c file scope 내에는 존재하지 않는다.\n하지만 sub.c 를 보면 전역 변수로 int test=100 이 존재 한다.\n그럼 이제 어느정도 감이 왔을겄이다.\nextern은 file scope를 벗어나서 다른 file scope내에 있는\n전역 변수를 사용하고자 할때 쓰는것.\nextren 은 다른 file scope 의 전역 변수의 사용을 가능케 한다.\n그럼 이제 예시를 살펴보자.\n//t1.c #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;t.h\u0026#34; extern int test; int main(){ printf(\u0026#34;%d\\n\u0026#34;,test ); test+=1; printf(\u0026#34;%d\\n\u0026#34;,test ); add(); } //t2.c #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;t.h\u0026#34; int test=100; void add(int i){ printf(\u0026#34;%d\\n\u0026#34;,test ); } //t.h void add(); t1.c 는 t2.c 의 test를 가져 와서 출력후 1증가 한후 다시 출력해준다.\n그리고 add 함수를 호출하는데, 이 함수는 t2.c에 있다.\n그럼 t1.c에서 1을 증가 시켰던 test값이 t2.c에서 그대로 적용되는지 확인해 보는 예제이다.\n그럼 결과를 살펴 보자\n100 101 101 물론 t1.c에서 증가 시켰던 test의 값이 t2.c에서도 그대로 적용되었다.\n이러한 현상을 linkage 라고 한다.\n메모리에는 어떻게 저장되어 있을까?\ndata segment 에 저장되어 있다.\nextern으로 선언자를 지정해도 결국 초기화된 전역 변수 이므로 data segment에 저장된다.\n이제 scope에 대해 어느정도 이해를 했을 것이다.\n추후 내용에 Parameter 와 Argument 에 대한 내용이 나온다.\n이둘의 관계처럼 선언자와 식별자의 관계는 중요하다.\n상수, 변수 변수(Variable) : 정수, 실수, 문자, 문자열 등의 형태를 갖춘 가변 데이터.\n변수는 두가지 특징을 갖는다.\nScope - 특정 code block 안에서 실행, 참조된다.\nLife time - 특정 code block안에서 존재하고 벗어나면 소멸 한다\n일반 변수\n일반적으로 사용하는 자료형에 해당하는 대입 변수이다.\n//일반 변수 = 데이터 int a=4; double b=3.2; char p=\u0026#39;a\u0026#39;; 포인터 변수\nint temp_int=4; double temp_d=3.4; //포인터 변수 = 주소 int *a=\u0026amp;temp_int; int *c=\u0026amp;3; double *b=\u0026amp;temp_d; char *p=\u0026#34;abc\u0026#34;; 상수(Constant) : 값이 바뀌지 않는 데이터를 상수라 한다.\n변수 상수화\n변수 앞에 const를 붙여주면 상수가 된다.\nconst int a; =\u0026gt; 상수로 정해진 변수는 값을 바꾸는것이 불가\n매크로를 통한 상수화\n# define 을 통해서 상수를 만들수 있다. 매크로는 전처리기에 의해 변환 되고\n전역변수 처럼 사용 가능 하다. 위치는 헤더 파일 제일 밑에 사용해주면된다.\n#include \u0026lt;stdio.h\u0026gt; #define pi 3.14 #define poweroftwo 2 ex) 정수 상수 =\u0026gt; -2,-1,0,1,2,3\u0026hellip;.\n​ 실수 상수 =\u0026gt; -1.2, -0.2231, 3.14\u0026hellip;\n​ 문자 상수 =\u0026gt; \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo; ,\u0026lsquo;ㄱ\u0026rsquo;,\u0026lsquo;A\u0026rsquo;,\u0026lsquo;a\u0026rsquo;\u0026hellip;\n​ 문자열 상수 =\u0026gt; \u0026ldquo;abc\u0026rdquo;, \u0026ldquo;ABC\u0026rdquo;\u0026hellip;\n정수형 상수의 컴파일후의 비트 형태\n정수형 상수는 컴파일되면 4바이트 크기의 2진수 형태로 변환 된다.\n예를 들어 정수 13이 컴파일 되면, 나머지 비트는 0으로 채워 지게 됩니다.\n0000 0000 0000 0000 0000 0000 0000 1101 \u0026lt;--MSB LSB--\u0026gt; 여기서 중요한 개념이 나옵니다. MSB와 LSB가 무었인가\nMSB는 Most significant bit 라 하며 가장 왼쪽의 비트는 전체 값에서 가장 큰 비중을 차지한다.\nLSB는 Least significant bit 라 하며 가장 오른쪽의 비트는 전체 값에서 가장 작은 비중을 차지한다.\n예를 들어,\n1000 0000(128) \u0026gt; 0111 1111(127) 극단 적인 예로 128과 127의 차이를 보면된다. 뇌피셜로는 비트가 1인 비트가 많을수록 숫자가 크다. 물론 맞는 말이지만 모든경우에 해당되지는 안는다. 위의 예처럼 오른쪽 7비트가 전부 1인 값보다 가장 왼쪽 1비트가 1인 값이 크다. 그렇다면, 비트가 큰값으로 움직일때는 MSB의 움직임을 보면될것이다. 만약 작은 단위로\n비트가 움직여야 한다면, LSB를 보면 되는데 이때 한가지 예를 살펴봐야 한다.\n(0x8E)1000 1101(141) --\u0026gt; (0x8D)1000 1110(142) 1가장 왼쪽 LSB의 1비트 움직임을 보일때 Niddle단위로 비트가 이동한다고 한다. 실수형 상수의 컴파일후의 비트 형태\nsingle, double, quad 세가지 형태가 있고, 그중에서 double형태를 살펴본다.\n0 00000000000 00000... 부호비트(1) 지수 저장 비트(11)\t소수 저장 비트(52) =\u0026gt; 8byte(64bit) //소소부 1 1 1 ... 2^-1 2^-2 2^-3 ... 위의 예시처럼 소수부는 2의 -n제곱의 형태를 띈다. 때문에 소수르 사용한 계산은 정확하지 안을수 있다. 2^-1 =\u0026gt; 1/2 이고 0.5이다. 2^-2 =\u0026gt; 1/4 이고 0.25이다 2^-3 =\u0026gt; 1/8 이고 0.125이다. 소수부분이 5의 나머지 연산으로 처리 되는점을 보면, 0.3 같은 표현은 다루기 힘들다. 강제 형변환 vs 자동 형변환 자동 형변환\n자동 형변환은 더 작은 자료형에서 더큰 자료형으로 assign할때 발생.\nint a=8,b=2; double b=a/b; printf(\u0026#34;%f\\n\u0026#34;,b); //실행결과 4.000000 우리가 원하는 값은 4였을 터이지만 실제 출력값은 4.000000이 나온다.\ndouble은 8바이트를 할당하고 지수부분에 11비트 소수부분이 52비트를 저장한다.\n때문에 지수부분 4와 소수부분 52비트 즉 6바이트 0.000000 이기 때문에\n소수점 밑으로 6자리를 표기한다.\n강제 형변환\n위와 같은 경우에서 원하는 값인 2로 표기할수도 있다.\nprintf(\u0026#34;%d\u0026#34;,(int)b); //실행결과 4 물론 강제 형변환은 포인터 에서도 많이 쓰인다.\n함수 포인터, byte access 를 참고.\n전달 인자(Argument)와 매개변수(Parapeter) int *a = \u0026amp;temp; 매개변수 전달인자 int add(int *a){} 매개변수 add(\u0026amp;temp); 전달인자 LIttle and Big Endian int a=1; =\u0026gt; 0x 00 00 00 01 Little Big |___01___|___00___| 0x7fff2ab9 |___00___|___00___| |___00___|___00___| |___00___|___01___| |________|________| 시스템마다 little endian, big endian 두가지 방법중 하나를 채택한다.\n하지만 다양한 종류의 컴퓨터들끼리 통신을 해야 하는데, 이때 데이터를 읽어서 저장하는 방법이\n다르다면 문제가 생긴다 때문에, 한가지로 통일해 줘야 한다.\n이떄 사용 되는 방법이 Byte Access이다\nDigital logic circuit(DLD) Bitwise 특정 비트 on/off\n예를들어 Led의 한부분을 껏다 켯다 하는 동작이 발생할수도 있다.\nLED와 연결되어 있는 특정 주소의 값에 한 비트를 on/off해야 동작 할때\n다음과 같은 비트 연산으로 수행 가능하다.\nres =\u0026gt; 0x 1111 0111 res\u0026amp;=~(0x01 \u0026lt;\u0026lt; 7); 0111 1111 (~res) \u0026amp; 1111 0111 (res) _____________ 0111 0111 =\u0026gt; 가장 오른쪽 1비트만 off가 되었다 이처럼 특정 비트를 on/off할때에 ~(not)과 \u0026amp;(and)연산이 필요하다. Basic of Loop 프로그래밍중에 실수와 의도에 의해서 무한 루프가 발생하거나 써야 하는 일이 있다.\n의도치 않은 무한 루프\n대부분 세미 콜론이나, 조건식을 잘못 써서 발생한다.\n//case1 int val=0; while(val\u0026lt;5); =\u0026gt; while문의 내용이 시작하기 전에 세미콜론을 사용하였다. { printf(\u0026#34;a\\n\u0026#34;); } 결과는 물론 무한 루프이다. while 문의 조건식을 잘못 적용 하였고 루프에 빠지게 될텐데, while 문의 내용이 시작하기 전에 세미 콜론으로 마무리 했다. 때문에 printf 는 while 문의 무한 루프 때문에 출력이 되질 않는다. //case2 int val=0; for(val=0;val\u0026lt;5;val++); =\u0026gt; for문의 내용이 시작도 전에 세미콜론이 찍혔다. { printf(\u0026#34;aa\\n\u0026#34;); } 이번엔 어떨까? aa가 5번 찍히는가? 아니다. for문의 내용이 시작도전에 세미콜론이 있기 때문에, for문만 5번 돌아가고나서 printf 는 한번만 사용된다. 즉 aa는 한번만 출력되는것!! 그럼 중괄호(\u0026#39;{}\u0026#39;)의 역할은 뭘까? 보통 중괄호는 코드의 영역을 나타낸다. 의도한 루프\nFirmware 등의 기본 동작에 필요한 경우가 있다. 혹은 지연 시간을 위해 고의적으로 넣는 경우도\n있는데, 지금은 펌웨어에서 필요로 하는 Polling 방식에 대해 기술해 보려 한다.\nPolling\n폴링방식은 하나의 프로그램에서 상태를 주기적으로 체크하여, 조건에 해당될때 송수신하는 목적이다.\n예를 들어 보자, 세탁기 같은 내장프로그램을 봤을때, 시작과 종료 후에 다시 시작을 눌러도\n기계는 작동한다. 이는 폴링 방식에 의해서 주기적으로 루프를 돌고 있기 때문이다.\nwhile(1){ 조건1 조건2 조건3 ... } 프로그램은 계속해서 주기적으로 조건이 만족한 명령을 수행후 다시 while 문 의 처음으로 돌아와서 처리한다. Interrupt\n인터럽트 방식은 특정 이벤트가 발생했을때 동작을 멈추고 해당 이벤트를 처리하는것\n주로 OS를 대표적인 예로 들수 있다. 만약 종료라는 이벤트가 발생한다면, cpu는 그즉시\n모든 연산을 멈추고 종료를 처리한다.\n물론 인터럽트 방식은 예기치 못한 상황에 대비할때 좋은 방법이다.\nArray 배열은 자료형의 집합이라고 생각할수 있다. 배열은 메모리 Stack 에 할당되며, main부분에 사용된\n배열은 프로그램 시작에 생성되고 종료시 삭제 된다. 하지만 함수 부분에서 사용한 배열은 함수 종료와 함께 사라진다. 때문에 동적할당의 필요성이 대두 될때가있다.\nint arr[5]; 여기서 int 는 배열의 자료형이고 arr은 배열명이다. 이제는 배열을 활용하는법을 알아야 한다.\n배열에 접근해서 직접 자료를 처리해서 프로그래밍을 해야한다.\n때문에 배열에 접근 하는 방법을 알필요가 있다.\n직접 접근(Direct access)\n배열에 직접적으로 접근하는 방법이다.\narr[0]=5; printf(\u0026#34;%d\\n\u0026#34;,arr[1]); 간접 접근(Indirect access)\n*(Asteric)에 관한 표현이 나오는데 이는 포인터의 개념이다.\n해당 주소의 값을 가져 온다고 생각 하면 된다.\n*arr=5; printf(\u0026#34;%d\\n\u0026#34;,*(arr+1)) 이제 배열을 사용하면서 주의해야 할사항들이 있다.\nint arr[5]; arr != arr[0] 배열의 시작 주소 배열의 0번째 값 *arr == \u0026amp;arr[0] 배열의 시작 주소 배열의 0번째 주소 배열의 시작 주소는 배열의 0번째 주소화 일치한다 arr이라는 배열명은 수정 불가능한 포인터 상수이다.\n만약 inr arr[5]; 선언후, arr의 주소가 0x2000번지 일때 0x3000번지로 수정하는것 불가!\n배열은 한번 스택에 할당 되면 고정된다.\n배열의 각 요소 들간의 차이는 배열의 자료형의 크기에 달려 있다.\narr[0] -\u0026gt; arr[1] -\u0026gt; arr[2] 0x0200 4byte 0x0204 4byte 0x0208 Shallow copy(얕은 복사) vs Deep copy(깊은 복사) Shallow copy(얕은 복사) Deep copy(깊은 복사) Function 함수는 3가지 단계이자 요소가 필요하다.\n함수의 원형\nmain문 시작전에 전저리 부분 다음에 기술해줘야 한다.\n#include \u0026lt;stdio.h\u0026gt; void display(); int add(int a,int b); 위의 예시처럼 원형을 기술할 때에는 매개변수부분은 써줘도되고 안써줘도 된다.\n함수의 호출\nint main(){ int res=0; int a=3,b=10; display(); res=add(10,20); printf(\u0026#34;%d\u0026#34;,add(a,b)); } 함수의 정의\nvoid display(int *ptr,int idx){ for(int i=0;i\u0026lt;idx;i++) printf(\u0026#34;%d has %d\\n\u0026#34;,i,*(ptr+i)); } Pointer 포인터라 하면 c언어의 포기하는 break point일지도 모른다. 하지만 포인터를 활용 하지못한다면\n다양항 프로그래밍이 불가능 하다 포인터 부분은 자다가도 벌떡 일어나서 정의할수 있어야한다.\n주소 연산자(\u0026amp;)\n\u0026amp;(Ampersand) 엔드 연산자, 주소연산자 등등으로 불린다. 정확한 명칭은 Ampersand이다.\n주소 연산자는 해당 변수, 함수 등의 주소를 확인할수 있게 합니다.\n주소에 대해 생소할수 있습니다. 프로그램 실행시에 컴파일러에 의해 메모리에 각 영역에 따른 변수나 함수 등이 할당됩니다. 첫번째 예는 변수 입니다.\nLocal \u0026amp; Gloal Variable\nLocal Variable은 지역 변수라고도 하며, 해당 함수 범위 내에서만 사용할수 있는 변수입니다.\nGlobal Variable은 전역 변수 라고도 하며, 코드 내의 그 어떤 부분에서도 사용할수 있습니다.\n이제 두변수의 사용 예를 살펴보려 합니다.\nint global_b=10; int main(){ int local_a=10; static int global_a=20; printf(\u0026#34;In main funtion local variable local_a has %d\\n\u0026#34;,local_a ); printf(\u0026#34;In main funtion local variable local_a address %p\\n\u0026#34;,\u0026amp;local_a ); printf(\u0026#34;In main funtion static global_a has %d\\n\u0026#34;,global_a ); printf(\u0026#34;In main funtion static global_a address %p\\n\u0026#34;,\u0026amp;global_a ); printf(\u0026#34;In main funtion global variable global_b has %d\\n\u0026#34;,global_b ); printf(\u0026#34;In main funtion global variable global_b address %p\\n\u0026#34;,\u0026amp;global_b ); local_func(local_a,global_a); point_func(\u0026amp;local_a); printf(\u0026#34;%d\\n\u0026#34;,local_a); } void local_func(int a,int b){ printf(\u0026#34;In local funtion printf local_a has: %d address: %p\\n\\n\u0026#34;,a,\u0026amp;a); printf(\u0026#34;In local funtion printf global_a has: %d address: %p\\n\\n\u0026#34;,b,\u0026amp;b); printf(\u0026#34;In local funtion printf global_b has: %d address: %p\\nbut not using parameter\\n\u0026#34;,global_b,\u0026amp;global_b); a=10; printf(\u0026#34;a=10;\\nlocal_a change 10 to 20 not using poiter\\n\u0026#34;); } void point_func(int *p){ *p=100; } 메인 함수에서 local_a와 global_a를 선합니다. 하지만 global_a는 앞에 static이 붙습니다.\n왜일까요? 바로 전역 변수 처럼 사용하기 위합입니다. 변수 앞에 static을 붙이면 전역 변수 저장 영역인 data영역에 할당됩니다. 마치 전역변수 처럼요.\nIn main funtion local variable local_a has 10 In main funtion local variable local_a address 0x7ffeed43898c In main funtion static global_a has 20 In main funtion static global_a address 0x1027c801c In main funtion global variable global_b has 10 In main funtion global variable global_b address 0x1027c8018 //into local_fun In local funtion printf local_a has: 10 address: 0x7ffeed43894c In local funtion printf global_a has: 20 address: 0x7ffeed438948 In local funtion printf global_b has: 10 address: 0x1027c8018 but not using parameter a=20; local_a change 10 to 20 not using pointer //end local_func after local_func, a has 10 local_a passing by point_func //into point_func In point_func change local_a 10 to 100 //end point_func after point_func, Now local_a has 100 local_func에서 local_a의 값을 변화 시키려 했지만 메인 함수에서 local_a의 값을 출력해보니 그대로 입니다. 왜일까요?\nlocal_fun는 전달 인자를 int a로 받았습니다. 이러한 매개변수는 값의 복사가 발생합니다.\n바로 call by value 의 상황이죠. 즉, 메모리에 변수의 복사가 발생하고, 이 변수는 함수의 종료와\n동시에 바로 삭제 됩니다.\ncall by value int main(){ int local_a=10; static int global_a=20; local_func(local_a,global_a); } void local_func(int a,int b){ =\u0026gt; 변수의 값을 함수의 변수로 복사하는것입니다. a=20; =\u0026gt;함수 내부의 변수는 함수의 시작과 동시에 생성되고 종료와 함께 반환됩니다. b=400; } Call by value는 매개변수로 값을 받아와 함수의 메모리로 복사해오는것 입니다.\n그래서 함수내부에서 아무리 값을 바꿔도, 실상은 함수로 복사된 값을 변환하는 것이므로,\n본래의 전달인자로 들어온 변수는 그대로입니다.\n그럼 본래 변수의 값을 바꾸려면 어떻게 해야할까요?\ncall by reference(call by address) 사실 C에서는 Call by reference 가 완벽하게 작동하지는 않습니다.\n아이라 폴과 알켈리의 A Book on C 에서 P.252 의 call by reference 를 언급하자면,\nHow the used of addresses of variables as arguments to functions can produce\nthe effect of \u0026ldquo;call by reference\u0026rdquo;.\n라고 명시되어 있습니다.\n다른 언어에서는 call by reference의 mechanism이 존재 하지만 C에서는 존재 하지 않습니다.\n하지만 비슷한 동작을 할수 있게끔 만들어줄수는 있습니다. 일단 예제를 보죠.\nint main(){ int a=3, b=7; printf(\u0026#34;a: %d b: %d\\n\u0026#34;,a,b); swap(\u0026amp;a,\u0026amp;b); printf(\u0026#34;a: %d b: %d\\n\u0026#34;,a,b); } void swap(int *a, int *b){ int temp; temp=*a; *a=*b; *b=temp; } 이전의 call by value에서는 함수에서의 값의 복사 때문에 본래의 변수의 값은 변하지 안았습니다.\n근데 이번 함수 swap은 매개변수(int *a)가 포인터이며, 전달인자(\u0026amp;a)를 변수의 주소를 받고있습니다.\n결과는 어떨까요?\na: 3 b: 7 a: 7 b: 3 값의 변화가 있습니다. 뭘까요?\n바로 call by reference의 효과 입니다. 변수의 주소를 전달 받아 직접 값을 바꾸는 것이죠.\n하지만 A Book on C에서 언급했던 완벽한 call by reference가 아닌 이유가 여기있습니다.\n사실상 주소를 전달받아 값을 바꾼 다는 것은, 주소의 값을 call by value한다는 것이죠.\n잘 이해가 안가는데 다음 예제를 살펴보죠.\n//출처 : 나무위키 void testFunc(int* fptr) { fptr = NULL; } int main(void) { int num = 12; int* ptr = \u0026amp;num; printf(\u0026#34;%d\\n\u0026#34;,*ptr ); testFunc(ptr); printf(\u0026#34;%d\\n\u0026#34;,*ptr ); return 0; } testFunc라는 함수는 포인터를 인자로 받아 포인터의 값을 NULL로 바꿉니다.\n자 그러면 코드를 어떻게 동작을 할까요?\n메인 함수에서 ptr은 num 의 주소를 갖고 있습니다. 그리고 그 주소에 대한 값을 testFunc에\n전달 하고 있습니다. 그럼 testFunc를 완료 하고 나면 ptr에는 NULL이 저장 될테고,\n더이상 num을 가르킬수 없습니다. 과연 결과도 그럴까요?\n12 12 예상과는 다르게 num의 값은 변하지 안았습니다.\n이게 뭘 뜻하는 걸까요?\nC에서는 주소값을 전달 받아 해당 주소로 이동후 값을 변화 할수 있지만, 그 과정에서 정확히는\n전달 인자로 포인터 변수를 전달한다. 즉, 포인터 변수 ptr을 전달 하므로 이는 call by value\n라고 할수 있다. 그러므로 C에서는 call by reference는 없다고 정의 할수 있다.\n다시 말해 함수에 인자를 받아 인자값 자체를 변화 시키는 것은 불가능 하다, 하지만 인자값의 주소로 건너가 그 값을 바꾸는 것은 가능하다, 하지만 이것은 값의 의한 복사 call by value 이다.\n하지만 call by value 로 전달하는 value 가 주소값이 이기 때문에 call by value 라고 부는것!!\n결론은 call by reference가 아니라 call by address or call by pointer\n라고 불러야 한다.\n그럼 진정한 call by reference는 어디에 존재하는 것이가?\n바로 c++부터 그 개념이 등장한다.\ncall by reference c++ 에서는 참조 변수 라는 것이 존재한다.\nint a=10; int \u0026amp;b=a; c에서는 \u0026amp;(ampersand)는 주소 값의 반화을 의미했다. 하지만 c++에서는 참조 매개변수가 존재 하며\n값을 복사 하는 call by value 가 아닌 주소 값을 받아와 참조에 의한 접근이 가능하다.\n다음 c++ 예시를 살펴보자.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; void func1(int *q); void func2(int *q); void func3(int \u0026amp;q); int main(){ int a=10; int *point=\u0026amp;a; printf(\u0026#34;a address: %p value: %d \\n\\n\u0026#34;,\u0026amp;a,a); func1(\u0026amp;a); printf(\u0026#34;After func1 a value: %d\\n\u0026#34;,a); printf(\u0026#34;\\n===================================\\n\u0026#34;); printf(\u0026#34;point address:%p point has : %p value: %d \\n\u0026#34;,\u0026amp;point,point,*point ); func2(point); printf(\u0026#34;After func2 a value: %d\\n\u0026#34;,a); printf(\u0026#34;\\n===================================\\n\u0026#34;); printf(\u0026#34;Now we declaration int \u0026amp;ref_point=a\\n\u0026#34;); int \u0026amp;ref_point=a; printf(\u0026#34;point address:%p point has : %p value: %d \\n\u0026#34;,\u0026amp;point,point,*point ); func3(ref_point); printf(\u0026#34;After func3 a value: %d\\n\u0026#34;,a); } void func1(int *q){ printf(\u0026#34;In Func1\\nNow we change value of a to 100\\nSo q=20;\\nif you think change the value?\\n\u0026#34;); //q=20; printf(\u0026#34;q=20; is error occured\\n\u0026#34;); printf(\u0026#34;q address: %p value: %d \\n\u0026#34;,\u0026amp;q,*q); printf(\u0026#34;a address: %p value: %d \\n\u0026#34;,q,*q); } void func2(int *q){ printf(\u0026#34;In Func2\\nNow we change value of a to 100\\nSo *q=100;\\nif you think change the value?\\n\u0026#34;); *q=100; printf(\u0026#34;q address: %p value: %d \\n\u0026#34;,\u0026amp;q,*q); printf(\u0026#34;a address: %p value: %d \\n\u0026#34;,q,*q); } void func3(int \u0026amp;q){ printf(\u0026#34;In Func3\\nNow we change value of a to 100\\nSo *q=3000;\\nif you think change the value?\\n\u0026#34;); q=3000; printf(\u0026#34;q address: %p value: %d \\n\u0026#34;,\u0026amp;q,q); } 내용이 복잡하다. 우선 각 함수들이 뭘하는 지를 살펴보자.\nfun1~3까지의 함수가 존재하는데,\nfunc1\n//일반 적인 c에서의 call by address의 예시이다. void func1(int *q){ printf(\u0026#34;In Func1\\nNow we change value of a to 100\\nSo q=20;\\nif you think change the value?\\n\u0026#34;); //q=20; =\u0026gt; 진정한 call by reference가 되려면 주소로 받아온 값을 바꿀수 있어야한다. printf(\u0026#34;q=20; is error occured\\n\u0026#34;); printf(\u0026#34;q address: %p value: %d \\n\u0026#34;,\u0026amp;q,*q); printf(\u0026#34;a address: %p value: %d \\n\u0026#34;,q,*q); } func1은 매개변수로 포인터 변수 를 사용 하며, 전달 인자로 주소를받는다.\n만약 q=20을 하면 어떻게 될까?\n사실상 main함수에서 int *point=\u0026amp;a; 라고 선언했다는 것은\n//예를 들어 변수 q는 0x2000에 존재 하며 a변수는 0x1000에 있다고 치자. point == \u0026amp;a ==0x1000 \u0026amp;point == 0x2000(address of q q변수의 주소) *point == a(a의 값 10) 이제 위의 내용을 머리속에 넣고 정신 단디 차리고 하나씩 해석해 보자.\n먼저 func1에에서 전달 인자로 \u0026amp;a를 전달 했고 *q 포인터 변수로 받았다.\n이때 무슨일이 생길까?\n//In func1 //메인 함수에서 a의 주소를 전달 했다. //그러면 func1함수에서는 함수 시작과 동시에 int *q에 대한 변수 공간을 생성한다. //위에서 a변수의 주소는 0x1000이였다. 그렇다면 함수로 a의 주소를 전달하고 나서도 //그래도 a의 변수를 참조하여 접근이 가능할까? //진정한 call by reference 라면 받아온 주소로 바로 접근이 가능해야할것이다. //===============컴파일 결과============== a address: 0x7ffee1f8173c value: 10 In Func1 Now we change value of a to 100 So q=20; if you think change the value? q=20; is error occured q address: 0x7ffee1f816e8 value: 10 a address: 0x7ffee1f8173c value: 10 After func1 a value: 10 결과를 살펴 보자.\n우리가 원하는 결과는 받아온 a의 주소와 매개변수 q의 주소가 같아야한다.\n근데 보아하니 주소값은 두개가 존재한다. 이건 뭘 뜻할까?\nfunc1이 실행되는 순간 int *q 에 대한 변수 공간이 마련된다.\n이곳은 주소는 0x7ffee1f816e8 이다. 그리고 해당 주소한에 들어있는 값이 0x7ffee1f8173c(a의 주소)이다.\n즉 값에 의한 복사인 call by value 로 인해 a의 주소 값을 받아와 접근한다는것이다.\n때문에 q안에는 a의 주소값인 0x7ffee1f8173c 이 들어 있고 ,\nq=20; 이라는 재할당을 한다는 것은 q가 갖고는 있는 값을 20 으로 바꾼 다는 것이고,\nq는 포인터 변수 이기 때문에 20의 주소에 있는 값을 가져와야 한다고 해석한다.\n하지만 마음대로 메모리를 접근할수는 없다 컴파일 단계에서\n이런 위험한 코드는 막아 버리기때문에 에러를 토해낸다.\n결국 func1은 call by value 에 의한 함수 내부의 포인터 변수 공간에\n전달 인자로 받아온 a의 주소를 저장 하여 a의 값에 접근 한다는것이다.\n진정한 call by reference 는 실패 했다.\n그럼 이제 두번째 함수 func2 를 살펴보자.\nfunc2\nvoid func2(int *q){ printf(\u0026#34;In Func2\\nNow we change value of a to 100\\nSo *q=100;\\nif you think change the value?\\n\u0026#34;); *q=100; printf(\u0026#34;q address: %p value: %d \\n\u0026#34;,\u0026amp;q,*q); printf(\u0026#34;a address: %p value: %d \\n\u0026#34;,q,*q); } 사실상 func1과 별 차이가 없다. 하지만 func2에서는 a의 변수를 포인터로 접근하여\n값을 변경하기 때문에 a값의 변화가 생긴다.\n하지만 위에서 봤듯이 이는 call by value 에 의한 call by reference 를 흉내 낸것이다.\n우리는 이러한 과정을 call by address or call by pointer 라고 부른다.\n그럼 진정한 call by reference 는 어떻게 해야 볼수 있을까?\n위에서 데니스 리치 의 말을 언급 하면 C에서는 call by reference 는 없다 .\n하지만 C++에서는 참조 변수라는것이 존재한다.\n이제 func3를 살펴 보자.\nfunc3\nint main(){ int a=10; ... int \u0026amp;ref_point=a; func3(ref_point); } void func3(int \u0026amp;q){ printf(\u0026#34;In Func3\\nNow we change value of a to 100\\nSo *q=3000;\\nif you think change the value?\\n\u0026#34;); q=3000; printf(\u0026#34;q address: %p value: %d \\n\u0026#34;,\u0026amp;q,q); } 우리가 알던 C의 문법에서는 볼수 없는 변수 선언이 있다. 이게 뭘까 싶다.\n일단 실행 결과를 살펴 보자.\n=================================== Now we declaration int \u0026amp;ref_point=a ref_point address:0x7ffeee79373c ref_point has : 100 In Func3 Now we change value of a to 3000 So q=3000; if you think change the value? q address: 0x7ffeee79373c value: 3000 After func3 a value: 3000 정말 신박함의 극을 달린다 할수 있다. int \u0026amp;ref_point=a 참조 변수에 a의 주소 값도 아닌\na를 할당 하고 있다. 그리고 ref_point의 주소를 출력해보니 ref_point의 별도의 변수 공간이 아닌\na의 주소를 출력하고 있다.\n그럼 함수 안에서는 어떨까?\n물론 q 변수에 대해서도 별도의 변수 공간을 할당하지 않는다.\n함수내에서도 a의 주소 를 출력하고 있으며, q로 값을 3000으로 재할당한후,\n함수가 종료되고 나서 a의 값을 출력해 보니 3000으로 바뀌어 있다.\n진정한 call by reference 란 값에 의한 복사를 통해 변수에 접근하는 것이 아닌\n값의 복사 없이 변수 자체에 접근 할수 있어야 한다는 것\n그래서 데니스 리치는 call by reference 에 대해\n\u0026hellip;\u0026ldquo;call by reference\u0026rdquo;\u0026hellip;, in which the called routine has access to the original argument, not a local copy.\n\u0026ldquo;호출 과정 내에서 지역 값의 복사 없이 원본 인자에 접근 할수 있어여하 한다\u0026rdquo; 라고 말한 것이다.\n","date":"June 11, 2018","hero":"/images/default-hero.jpg","permalink":"https://codex-devlab.github.io/posts/study/sub-programming-language/system-programming-ftw-implementation/","summary":"\u003ch1 id=\"c언어\"\u003eC언어\u003c/h1\u003e\n\u003cp\u003e프로그램이란? 컴퓨터에서 실행될때 특정 작업을 수행 하는 일련의 명령어들의 모음이다.\u003c/p\u003e\n\u003ch2 id=\"소프트웨어-공학\"\u003e소프트웨어 공학\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e요구사항 분석\n자료형 정의 등등\u003c/li\u003e\n\u003cli\u003eFlow chart 설계 및 구현(pseudo code)\u003c/li\u003e\n\u003cli\u003e코드 구현\u003c/li\u003e\n\u003cli\u003e실행\u003c/li\u003e\n\u003cli\u003e테스트\u003c/li\u003e\n\u003cli\u003e유지보수\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"cpu-구조\"\u003eCPU 구조\u003c/h2\u003e\n\u003cp\u003eControl unit\u0026lt;-\u0026gt;ALU\u0026lt;-\u0026gt;Processor resister(R1,R2,R3\u0026hellip;)\n위의 3가지 장치들이 Internal bus로 연결되어 통신한다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eALU(Arithmetic logic unit )\u003c/p\u003e\n\u003cp\u003e산술 논리 장치 : 실질적으로 산술, 논리 계산을 수행함.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eResister\u003c/p\u003e\n\u003cp\u003eCPU의 자체적인 메모리저장 기능.\u003c/p\u003e\n\u003cp\u003eMemory buffer register(MBR)\u003c/p\u003e\n\u003cp\u003e​\tI/O로 보내지거나 메모리에 저장될 Word 혹은 I/O나 메모리로 부터 Word를 받는 것.\u003c/p\u003e","tags":["Study","C","Theory"],"title":"C언어 스터디"},{"categories":null,"contents":" root Fire Fox Update GIT Installation and Setting Git multi user ssh setting Autojump Installation vim Installation and Setting vim scheme vim Plugin Install youcompleteme Airline ctag Mouse setting root $sudo passwd root Fire Fox Update $sudo apt-get firefox $sudo apt-get update GIT Installation and Setting 설치 $sudo apt install git 초기 설정 $git config --global user.name \u0026#34;kimleepark\u0026#34; $git config --global user.email kimleepark@gmail //$git config -l $ssh-keygen //.ssh 폴더안에 id_rsa.pub 의 내용을 Github ssh에 등록해준다. $git init $git log //git 작업 기록 $git status //git 현재 현황(add 되거나, 추적 가능한 파일 현황) $git add //-u 업데이트된 항목을 추적해서 add함, --all,-A 폴더내 모든 항목을 add함 $git commit $git push //local -\u0026gt; remote 저장소로 이동 $git pull //원격 저장소에 있는 변경 사항을 가져와서 merge함 Git 시작하기 를 참고 하시면서 작업 하시면 좋습니다.\n.gitignore 에 a.out, *.o, *.txt 등 을 추가하여 불필요한 형식은 걸러서 올리는것이 작업하기 편합니다.\npush 할때마다 아이디와 비밀번호 요구 일단 이유를 알아야 하니 여기참고해 주세요. ssh key 생성부터 설정\n\u0026gt;$ls -al ~/.ssh \u0026gt;//기존에 키가 존재 하는지 체크해 주세요. 아마 대부분 이미 ssh-keygen으로 만드셨을겁니다. \u0026gt;$ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; \u0026gt;//이후 나오는 설정 \u0026#34;아~ 잘모르궤쎠 엔터 누르롸눈거 가튠뒈 잘 모르게쒀 걍 무조건 엔터\u0026#34; \u0026gt;//뭐 순서대로 저장할 폴더, 패러프레이즈 에 대한 방식이니 그냥 엔터 눌러주세요. \u0026gt;$cat ~/.ssh/id_rsa.pub \u0026gt;//전부 복사해서 github sshkey 에 등록해주세요 \u0026gt;//등록후 조금 시간이 지나야 인증이 되니까 그동안 reboot해주세요 \u0026gt;$ssh -T git@github.com \u0026gt;//Hi~~어쩌구 나오면 ssh에 등록되고 연결이 된거에요. 그리고 대부분 아마 push할때 마다 id 와 pass를 물어보는 경우는 git clone시에 ssh가 아닌 http로 clone을 해서 그렇습니다. 그냥 간단하게 원래있던 폴더 삭제후 clone할때에 ssh로 clone하시면 id\u0026amp;pass 안물어봄.\n기존 로컬 저장소와 원격 저장소 연결 1.원격 저장소를 먼저 만들고 그냥 Clon $git clone https://원격저장소.git 2.기존로컬 저장소를 원격저장소와 연결 Github에서 resipotory를 먼저 만들어야 한다. $mkdir \u0026#34;resipotory와 같은 이름\u0026#34; //resipotory 이름은 foo라고 가정한다. $cd foo $git init //빈저장소를 만드는것 $git remote \u0026lt;name\u0026gt; \u0026lt;https://원격저장소.git\u0026gt; //name 간단하게 push할때마다 사용하는 브랜치 이름이다. $git remote show \u0026lt;name\u0026gt; //분명 HEAD 브랜치 : (unknown) 이라고 나올것이다. $git push \u0026lt;name\u0026gt; master Git multi user ssh setting 현재 사용하는 Git 계정이 두개입니다. 뭔가 생각에는 계정이 두개 있어도 한번 만들어져 있는\nssh key를 사용해도 될것 같지만, 이미 사용한 ssh key를 다른 계정에 등록하려고 하면\nkey is already used.라고 나옴니다. 때문에 추가 계정을 위한 ssh key가 필요합니다.\n먼저 .ssh 폴더안의 파일을 보면 이해가 빠릅니다.\n$cd ~/.ssh . ├── config -\u0026gt; 여러개정을 연결하기 위한 cofing ├── id_rsa ├── id_rsa.pub -\u0026gt; 원래 계정의 ssh key ├── id_rsa_blog └── id_rsa_blog.pub -\u0026gt; 추가 계정의 ssh key 일단 추가 계정을 위한 ssh key를 생성해야 합니다.\n$ssh-keygen -t rsa -C \u0026#34;username@gmail.com\u0026#34; //새 계정의 이메일 주소 Generating public/private rsa key pair. Enter file in which to save the key (/Users/Edwardson/.ssh/id_rsa): id_rsa_project //project는 임의로 작명해 주세요. ... $ssh-add ~/.ssh/id_rsa_project //ssh key 추가 $ssh-add -l //ssh key 저장 $vi config //이제 ssh가 두개가 됬으니 각각 생성된 key로 동작하도록 연결해줘야 합니다. //cofig를 .ssh안에 만들어줘서 다음 내용을 추가해 주세요. # default account Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa # project account Host github.com-project HostName github.com User git IdentityFile ~/.ssh/id_rsa_project $ssh -T git@github.com Hi \u0026#34;원래계정 이름 나옴\u0026#34;! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. $ssh -T git@github.com-project Hi \u0026#34;추가계정 이름 나옴\u0026#34;! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. //위에 처럼 확인 됬으면 새로운 git계정에 ssh를 연결해서 사용할 준비가 다됬습니다. //이제 이전에 했던 Git hub에 ssh 새로 생성한 키를 등록해 주세요. 자 이제 거의 다됬습니다. 추가 계정의 repository만 remote 해주면 되겠네요.\n$mkdir project \u0026amp;\u0026amp; cd project $git init $git config user.name project $git config user.email project@email.com $git remote add origin git@github.com-project:YOURNAME/REPOSITORY.git //아까 config 에서 설정했던 두번째 계정의 Host 가 github.com-project 였죠 //그래서 remote 로 연결해 줄때도 git@github.com-project로 연결해줘야 합니다. $echo \u0026#34;project\u0026#34; \u0026gt;\u0026gt; readme.md $git add -A $git commit -m \u0026#34;firstcommit\u0026#34; $git push -u origin master Autojump Installation $sudo apt-get install autojump //Ubuntu에는 패키지가 있어서 apt-get으로 설치 가능 $sudo apt-get update $autojump //분명 이부분에서 osX든 ubuntu든 bach 설정이 안되어 있어서 뭐라뭐라 나옴 $echo \u0026#34;. /usr/share/autojump/autojump.bash\u0026#34; \u0026gt;\u0026gt; ~/.bashrc //autojump가 터미널 실행시 바로 작동 할수 있게 경로를 추가해 줘야 한다. Autojump 를 참고하시길 바랍니다.\nvim Installation and Setting 설치 $sudo apt-get vim $sudo apt-get update vim scheme 후\u0026hellip;여러가지 준비해봤습니다. 제대로 모시겠습니다.Vim 설정\nvim scheme 여러가지 테마는 http://vimcolors.com여기에 많습니다. 테마가 들어가야할 위치는 /usr/share/vim/vimXX/colors 여기에 있습니다. vimXX는 Vim마다 버전이 다르기 때문에 본인에게 맞는 버전을 찾아 주면 될것 같네요.\n$sudo wget -O /usr/share/vim/vim74/colors/molokai.vim https://raw.github.com/tomasr/molokai/master/colors/molokai.vim //이런식으로 원하는 테마를 찾아서 바로 넣어주면 됩니다. 설정은 $vi ~/.vimrc colorscheme molokai 이렇게 넣어주면 되겠네요. vim Plugin Install 우선은 번들을 설치해 볼까요? 자세한 사항은 여기를 참고해 주세요\n$git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim $vi ~/.vimrc \u0026#34; set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() \u0026#34; alternatively, pass a path where Vundle should install plugins \u0026#34;call vundle#begin(\u0026#39;~/some/path/here\u0026#39;) \u0026#34; let Vundle manage Vundle, required Plugin \u0026#39;VundleVim/Vundle.vim\u0026#39; youcompleteme 자동 완성 플러그인 입니다. 자세한건 여기를 참고해 주세요\n$vi ~/.vimrc Plugin \u0026#39;Valloric/YouCompleteMe\u0026#39; //위 내용 추가후 :PluginInstall $ sudo apt-get install build-essential cmake $ sudo apt-get install python-dev python3-dev $ cd ~/.vim/bundle/YouCompleteMe $ ./install.py --clang-completer //youcompleteme 에서 특정 언어에 대한 자동완성을 지원하기 위해 각 언어의 지원을 받아야한다. //여기서 C 언어에 대해 지원하고 싶으면 ./install.py 할때 --clang-completer를 추가해 준다. //귀찬으면 그냥 -all 간혹 문제가 생길수 있다. vim에서 ycm_extra_conf.py이게 없다고 에러를 토해낼때!! 여기를 참고해도 되고 다음 처럼 해줘도 된다. let g:ycm_global_ycm_extra_conf = \u0026lsquo;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py\u0026rsquo; 추가 cd /.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm vim .ycm_extra_conf.py 여기서 compilation_database_folder = \u0026lsquo;\u0026lsquo;를 찾아 \u0026lsquo;\u0026lsquo;부분에 \u0026lsquo;/.vim/\u0026rsquo; 로 고친다.\nYCM Option .vimrc에 추가 \u0026quot;\u0026quot; turn on completion in comments let g:ycm_complete_in_comments=1 \u0026quot;\u0026quot; load ycm conf by default let g:ycm_confirm_extra_conf=0 \u0026quot;\u0026quot; turn on tag completion let g:ycm_collect_identifiers_from_tags_files=1 \u0026quot;\u0026quot; only show completion as a list instead of a sub-window set completeopt-=preview \u0026quot;\u0026quot; start completion from the first character let g:ycm_min_num_of_chars_for_completion=1 \u0026quot;\u0026quot; don\u0026rsquo;t cache completion items let g:ycm_cache_omnifunc=0 \u0026quot;\u0026quot; complete syntax keywords let g:ycm_seed_identifiers_with_syntax=1\nAirline 자세한건 여기를 참고해 주세요. 각종 정보들을 vim에 표시되게 합니다. 버퍼를 사용해 창을 나눌수도 있고 다른 플러그인에 같이 적용도 됩니다.(솔직히 그냥 간지)\n$vi ~/.vimrc Plugin \u0026#39;vim-airline/vim-airline\u0026#39; Plugin \u0026#39;vim-airline/vim-airline-themes\u0026#39; :PluginInstall 테마 적용 여기에서 원하는 테마를 찾고 밑에 처럼 적용해주면 됩니다. :AirlineTheme ctag 커널 프로그래밍 을 위해서 필수 절차이다.여기에 ctags에 대한 명령어등 튜토리얼이 있다.\n$sudo apt-get install exuberant-ctags $vi ~/.vimrc Plugin \u0026#39;xolox/vim-easytags\u0026#39; Plugin \u0026#39;xolox/vim-misc\u0026#39; //vim-misc는 easytags설치후 에러를 토하면서 misc 설치하라 하면 추가해주면됨 기본 사용법 Ctrl + ] - 함수, 구조체가 정의되어있는 곳으로 이동. Ctrl + t - 이동하기 전 소스코드 위치로 옴.\nMouse setting 시스템 설정 -\u0026gt; 마우스 설정 에 마우스 속도 조절이 없다.... 1. rc.local에 스크립트 파일 등록 [적용안됨] 2. init.d에 스크립트 파일 등록 [적용안됨] Runlevel=5\t#1~2번 까지 systemctl 로 상태를 확인해본 결과 똑같은 오류 메세지 나옴 unable to open display \u0026#34;\u0026#34; 이런식임 방법을 찾다가 display가 뜻하는것은 서버등 내 서버에 접속된 사용자들의 display 같음 하지만 난 솔플을 하는중이니 $echo $DIPLAY :0 일케 나옴 그러니당연히 매번 unable~ 이런식으로 오류를 던져줌 [해결] export XAUTHORITY=/home/codex/.Xauthority sh \u0026amp; xset -display :0 m 1/2 1/2 현재 내 display에 대한 정보와 권한을 가져오는것이 방법이였다. 근데 중요한건 결국 안됨....rc.local의 실행과정을 보니 parent에서 fork하는것이였고 현재 쉘에는 적용 안됨... 3.autostart에 스크립트 등록 [적용안됨] 4.autostart에 mate-mouse-property [적용됨] 근데 부팅되자마자 앱 화면이 로드됨 5. 런치패드 업데이트 [안됨] 6. 우분투 업데이트 [안됨] 7. Gnome으로 변경후 업데이트 [됨] ","date":"June 1, 2018","hero":"/images/default-hero.jpg","permalink":"https://codex-devlab.github.io/posts/os/sub-linux/debian-bases/ubuntu-setting/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#root\"\u003eroot\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#fire-fox-update\"\u003eFire Fox Update\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#git-installation-and-setting\"\u003eGIT Installation and Setting\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#git-multi-user-ssh-setting\"\u003eGit multi user ssh setting\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#autojump-installation\"\u003eAutojump Installation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#vim-installation-and-setting\"\u003evim Installation and Setting\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#vim-scheme\"\u003evim scheme\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#vim-plugin-install\"\u003evim Plugin Install\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#youcompleteme\"\u003eyoucompleteme\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#airline\"\u003eAirline\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ctag\"\u003ectag\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mouse-setting\"\u003eMouse setting\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"root\"\u003eroot\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$sudo passwd root\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"fire-fox-update\"\u003eFire Fox Update\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$sudo apt-get firefox\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$sudo apt-get update\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"git-installation-and-setting\"\u003eGIT Installation and Setting\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e설치\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$sudo apt install git\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e초기 설정\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$git config --global user.name \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;kimleepark\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$git config --global user.email kimleepark@gmail\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e//$git config -l\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ssh-keygen \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e//.ssh 폴더안에 id_rsa.pub 의 내용을 Github ssh에 등록해준다.\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$git init\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$git log\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e//git 작업 기록\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$git status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e//git 현재 현황\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003eadd 되거나, 추적 가능한 파일 현황\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$git add\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e//-u 업데이트된 항목을 추적해서 add함,  --all,-A 폴더내 모든 항목을 add함\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$git commit\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$git push\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e//local -\u0026gt; remote 저장소로 이동\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$git pull\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e//원격 저장소에 있는 변경 사항을 가져와서 merge함\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://git-scm.com/book/ko/v1/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Git-%EC%B5%9C%EC%B4%88-%EC%84%A4%EC%A0%95\" target=\"_blank\" rel=\"noopener\"\u003eGit 시작하기\u003c/a\u003e 를 참고 하시면서 작업 하시면 좋습니다.\u003c/p\u003e","tags":["OS","Ubuntu","초기설정","Git","Vim","Airline","Autojump"],"title":"Ubuntu \u0026 OSX setting"}]