<!doctype html><html lang=en><head><title>C언어 스터디</title>
<meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.ebdf1708425812742f06026e9c6504d6d04f47c35c98bf525d317b7a6ec6263a.css integrity="sha256-698XCEJYEnQvBgJunGUE1tBPR8NcmL9SXTF7em7GJjo="><link rel=icon type=image/png href=/images/site/way_out_hu_e82cf44f015f5054.png><meta property="og:url" content="https://codex-devlab.github.io/posts/study/sub-programming-language/system-programming-ftw-implementation/"><meta property="og:site_name" content="CodeXlog"><meta property="og:title" content="C언어 스터디"><meta property="og:description" content="C언어 관련 이론 정리"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-11T04:22:12+06:00"><meta property="article:modified_time" content="2018-06-11T04:22:12+06:00"><meta property="article:tag" content="Study"><meta property="article:tag" content="C"><meta property="article:tag" content="Theory"><meta name=twitter:card content="summary"><meta name=twitter:title content="C언어 스터디"><meta name=twitter:description content="C언어 관련 이론 정리"><meta name=description content="C언어 관련 이론 정리"><script async src="https://www.googletagmanager.com/gtag/js?id=G-FSLRPDG57K"></script><script>var dnt,doNotTrack=!1;if(null&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FSLRPDG57K")}</script><script>theme=localStorage.getItem("theme-scheme")||localStorage.getItem("darkmode:color-scheme")||"light",theme=="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-posts kind-page" data-bs-spy=scroll data-bs-target=#TableOfContents data-bs-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/site/way_out_hu_e82cf44f015f5054.png id=logo alt=Logo>
CodeXlog</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ms-auto"><li class=nav-item><a class=nav-link href=/#home>Home</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>Recent Posts</a></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>Posts</a></li><li class=nav-item><a class=nav-link href=/tags/>Tags</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=themeSelector role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false><img id=navbar-theme-icon-svg class=theme-icon src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme"></a><div id=themeMenu class="dropdown-menu dropdown-menu-icons-only" aria-labelledby=themeSelector><a class="dropdown-item nav-link" href=# data-scheme=light><img class=theme-icon src=/icons/sun-svgrepo-com.svg width=20 alt="Light Theme">
</a><a class="dropdown-item nav-link" href=# data-scheme=dark><img class=theme-icon src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme">
</a><a class="dropdown-item nav-link" href=# data-scheme=system><img class=theme-icon src=/icons/computer-svgrepo-com.svg width=20 alt="System Theme"></a></div></li></ul></div></div><img src=/images/site/way_out_hu_e82cf44f015f5054.png class=d-none id=main-logo alt=Logo>
<img src=/images/site/way_out_hu_e82cf44f015f5054.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=Search data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts/ data-filter=all>Posts</a></li><div class=subtree><li><i data-feather=plus-circle></i><a class=list-link href=/posts/blog-migration/> Blog-Migration</a><ul><li><a class=list-link href=/posts/blog-migration/sub-hugo/ title=Hugo>Hugo</a></li><li><a class=list-link href=/posts/blog-migration/sub-jekyll/ title=Jekyll>Jekyll</a></li></ul></li><li><i data-feather=minus-circle></i><a class="active list-link" href=/posts/study/> Study</a><ul class=active><li><i data-feather=plus-circle></i><a class=list-link href=/posts/study/sub-algorithms/> Algorithms</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/posts/study/sub-algorithms/online-judge/> Algorithms Problem</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/posts/study/sub-algorithms/online-judge/backjoon/> Backjoon</a><ul><li><a class=list-link href=/posts/study/sub-algorithms/online-judge/backjoon/prob-10871/ title=Problem.10871>Problem.10871</a></li><li><a class=list-link href=/posts/study/sub-algorithms/online-judge/backjoon/prob-1110/ title=Problem.1110>Problem.1110</a></li><li><a class=list-link href=/posts/study/sub-algorithms/online-judge/backjoon/prob-11654/ title=Problem.11654>Problem.11654</a></li><li><a class=list-link href=/posts/study/sub-algorithms/online-judge/backjoon/prob-1546/ title=Problem.1546>Problem.1546</a></li><li><a class=list-link href=/posts/study/sub-algorithms/online-judge/backjoon/prob-1978/ title=Problem.1978>Problem.1978</a></li><li><a class=list-link href=/posts/study/sub-algorithms/online-judge/backjoon/prob-2490/ title=Problem.2490>Problem.2490</a></li></ul></li></ul></li><li><a class=list-link href=/posts/study/sub-algorithms/data-structure/ title="Data Structure">Data Structure</a></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/study/sub-algorithms/programming-tips/> Programming Tips</a><ul><li><a class=list-link href=/posts/study/sub-algorithms/programming-tips/the-meaning-of-scanf-in-c-language/ title="C언어 Scanf 의 의미">C언어 Scanf 의 의미</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/study/sub-algorithms/etc-problems/> Etc Problem</a><ul><li><a class=list-link href=/posts/study/sub-algorithms/etc-problems/prob-snail/ title="Prob 달팽이 배열">Prob 달팽이 배열</a></li><li><a class=list-link href=/posts/study/sub-algorithms/etc-problems/prob-bigandsmall/ title="큰수 작은수로 정렬후 덧셈">큰수 작은수로 정렬후 덧셈</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/study/sub-computer-science/> Computer Science</a><ul><li><a class=list-link href=/posts/study/sub-computer-science/system-programming-ftw-implementation/ title="시스템프로그래밍 FTW 구현">시스템프로그래밍 FTW 구현</a></li></ul></li><li><i data-feather=minus-circle></i><a class="active list-link" href=/posts/study/sub-programming-language/> Programming Language</a><ul class=active><li><a class="active list-link" href=/posts/study/sub-programming-language/system-programming-ftw-implementation/ title="C언어 스터디">C언어 스터디</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/dev/> Dev</a><ul><li><a class=list-link href=/posts/dev/sub-tips/ title=Tips>Tips</a></li><li><a class=list-link href=/posts/dev/git/ title="Git Manual">Git Manual</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/os/> OS</a><ul><li><a class=list-link href=/posts/os/sub-bsd-based/ title="BSD-Based OS">BSD-Based OS</a></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/os/sub-linux/> Linux</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/posts/os/sub-linux/debian-bases/> Debain-Based OS</a><ul><li><a class=list-link href=/posts/os/sub-linux/debian-bases/ubuntu-setting/ title="Ubuntu & OSX setting">Ubuntu & OSX setting</a></li></ul></li><li><a class=list-link href=/posts/os/sub-linux/rhel-based/ title="RHEL-Based OS">RHEL-Based OS</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/os/sub-macos/> Mac OS</a><ul><li><a class=list-link href=/posts/os/sub-macos/mac-autojump/ title="Mac Autojump 설치및 사용법">Mac Autojump 설치및 사용법</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/os/sub-window/> Window OS</a><ul><li><a class=list-link href=/posts/os/sub-window/window-git-setting/ title="Git 설치 및 초기설정">Git 설치 및 초기설정</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(/images/default-hero.jpg)></div><div class=page-content><div class="author-profile ms-auto align-self-lg-center"><img class=rounded-circle src=/images/author/pigeon.gif alt="Author Image"><h5 class=author-name>DongjuSon</h5><p class=text-muted>Monday, June 11, 2018 | 21 minutes</p></div><div class=title><h1>C언어 스터디</h1></div><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/study/ class="btn btn-sm btn-info">Study</a></li><li class=rounded><a href=/tags/c/ class="btn btn-sm btn-info">C</a></li><li class=rounded><a href=/tags/theory/ class="btn btn-sm btn-info">Theory</a></li></ul></div><div class=post-content id=post-content><h1 id=c언어>C언어</h1><p>프로그램이란? 컴퓨터에서 실행될때 특정 작업을 수행 하는 일련의 명령어들의 모음이다.</p><h2 id=소프트웨어-공학>소프트웨어 공학</h2><ul><li>요구사항 분석
자료형 정의 등등</li><li>Flow chart 설계 및 구현(pseudo code)</li><li>코드 구현</li><li>실행</li><li>테스트</li><li>유지보수</li></ul><h2 id=cpu-구조>CPU 구조</h2><p>Control unit&lt;->ALU&lt;->Processor resister(R1,R2,R3&mldr;)
위의 3가지 장치들이 Internal bus로 연결되어 통신한다.</p><ul><li><p>ALU(Arithmetic logic unit )</p><p>산술 논리 장치 : 실질적으로 산술, 논리 계산을 수행함.</p></li><li><p>Resister</p><p>CPU의 자체적인 메모리저장 기능.</p><p>Memory buffer register(MBR)</p><p>​ I/O로 보내지거나 메모리에 저장될 Word 혹은 I/O나 메모리로 부터 Word를 받는 것.</p><p>Memory address register(MAR)</p><p>Instruction register(IR)</p><p>Instruction buffer register(IBR)</p><p>Program counter(PC)</p><p>Accumulator (AC) and mutiplier quotient (MQ)</p></li><li><p>Control unit</p><p>CPU의 명령어를 제어한다.</p></li></ul><h2 id=폰노이만-구조최초의-컴퓨터-구조를-만듬>폰노이만 구조(최초의 컴퓨터 구조를 만듬)</h2><p>폰노이만의 구조는 CPU, 메모리, 프로그램 구조를 갖는 프로그램 내장 방식 컴퓨터를 뜻한다.</p><p><img src=https://upload.wikimedia.org/wikipedia/ko/a/a1/Von_Neumann_architecture_kor.png alt=cpu구조>{: .center-image}</p><center>폰노이만 구조(출처: 위키 백과사전)</center><h2 id=c-메모리-구조>C 메모리 구조</h2><p><img src=https://1.bp.blogspot.com/-DoCFzIcQGDs/VlnGRLw69mI/AAAAAAAAAz0/xxrtrqK39FU/s1600/process%2Blooks%2Bin%2Bmemory.jpg alt="c메모리 구조">{: width=&ldquo;50%&rdquo; height=&ldquo;50%&rdquo;}<center>(출처 : <a href=https://bitsofcomputer.blogspot.com/ target=_blank rel=noopener>https://bitsofcomputer.blogspot.com/</a>)</center></p><p>c언어에서의 메모리 구조를 알고 있다는것은 상당히 중요하다.</p><p>주로 동적 할당 할때나 임베디드 시스템을 다룰때 메모리 구조와 영역을 알고 있으면 편하다.</p><h3 id=local-variables>local variables</h3><p>can be stored either on the stack or in a data segment depending on whether they are auto or static. (if neither auto or static is explicitly specified, auto is assumed)</p><h3 id=global-variables>global variables</h3><p>are stored in a data segment (unless the compiler can optimize them away, see const) and have visibility from the point of declaration to the end of the compilation unit.</p><h3 id=static-variables>static variables</h3><p>are stored in a data segment (again, unless the compiler can optimize them away) and have visibility from the point of declaration to the end of the enclosing scope. Global variables which are not static are also visible in other compilation units (see extern).</p><h3 id=auto-variables>auto variables</h3><p>are always local and are stored on the stack.</p><h3 id=the-register-modifier>the register modifier</h3><p>tells the compiler to do its best to keep the variable in a register if at all possible. Otherwise it is stored on the stack.</p><h3 id=extern-variables>extern variables</h3><p>are stored in the data segment. The extern modifier tells the compiler that a different compilation unit is actually declaring the variable, so don&rsquo;t create another instance of it or there will be a name collision at link time.</p><h3 id=const-variables>const variables</h3><p>can be stored either on the stack or a readonly data segment depending on whether they are auto or static. However, if the compiler can determine that they cannot be referenced from a different compilation unit, or that your code is not using the address of the const variable, it is free to optimize it away (each reference can be replaced by the constant value). In that case it&rsquo;s not stored anywhere.</p><h3 id=the-volatile-modifier>the volatile modifier</h3><p>tells the compiler that the value of a variable may change at anytime from external influences (usually hardware) so it should not try to optimize away any reloads from memory into a register when that variable is referenced. This implies static storage.</p><p><a href=https://www.geeksforgeeks.org/memory-layout-of-c-program/ target=_blank rel=noopener>geeks를 참고 하면서 공부해보자</a></p><p><a href=https://www.geeksforgeeks.org/storage-classes-in-c/ target=_blank rel=noopener>Storage class in C</a></p><h2 id=컴파일-과정>컴파일 과정</h2><ul><li><p>gcc compiler</p><p>source.c &mdash;&mdash;-> source.i &mdash;&mdash;-> source.s &mdash;&mdash;-> source.o &mdash;&mdash;-> source</p><p>​ (precompile) (compiler) (assembler) (linker)</p></li></ul><p><img src=https://www3.ntu.edu.sg/home/ehchua/programming/cpp/images/GCC_CompilationProcess.png alt=gcccompile></p><center>gcc compile 과정 (출처: 제타위키)</center><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ gcc test.c
</span></span><span style=display:flex><span>$ ls
</span></span><span style=display:flex><span> a.out 실행 파일 생성
</span></span><span style=display:flex><span>$ gcc -c test.c
</span></span><span style=display:flex><span> test.o 오브젝트 파일 생성
</span></span><span style=display:flex><span>$ gcc -o test.out test.o 
</span></span><span style=display:flex><span> test.out 실행 파일이 생성됨
</span></span><span style=display:flex><span>$ gcc -v --save-temps -o test.out test.c 컴파일 전체 과정을 보여주고 파일을 저장해줌
</span></span><span style=display:flex><span>    test.c test.i test.s test.o test.out
</span></span></code></pre></div><h2 id=c-concept>C Concept</h2><p>일단 이부분은 <a href=http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf target=_blank rel=noopener>ISO/IEC 9899:TC3</a> 의 표준을 보고 작성하였다.</p><h3 id=scope>scope</h3><p>scope에 자세히 들어가기 전에 먼저 선행되야 하는 개념이있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#66d9ef>int</span>    i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>선언자</span>  <span style=color:#960050;background-color:#1e0010>식별자</span>
</span></span></code></pre></div><p>코딩을 하면서 <code>int i</code> 정수형 변수 선언은 그냥 자연스레 넘어갔었다.</p><p>하지만 scope를 이해하기 위해서 더욱 자세하게 파고들어 보자.</p><p>두가지 개념을 살펴보자.</p><h4 id=declarator>Declarator</h4><p>선언자 라고 하며, Type declarator라고도 한다.</p><p>선언자의 역할은 변수의 형을 지정 하는것이다.</p><p>위의 예제에 적용해 보자면 <code>int</code> 는 정수형 선언자 이다.</p><h4 id=identifier>Identifier</h4><p>식별자 라고하며, 형선언자로 인해 특정 데이터 형을 가질수 있는 변수가 된다.</p><p><code>int</code> 는 Type sepcifier(형식 지정자) 라고 한다.</p><p>즉, <code>i</code> 는 <code>int</code> 형 변수에 대한 식별자이다.</p><p>하지만 식별자는 반드시 변수에만 해당하는 것은 아니다.</p><p>예를 들어 <code>void main</code> main은 void형 함수에 대한 식별자 이며,</p><p><code>printf()</code> 는 printf 함수에 대한 식별자 이다.</p><h4 id=visible>Visible</h4><p>식별자는 오직 자신이 존재 하는 scope안에서만 사용될수 있다.</p><p><code>Inner Scope</code> , <code>Outer Scope</code>의 개념을 이해 하는게 편할것 같다.</p><p>예제를 살펴 보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> glo<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(){ <span style=color:#75715e>//scope 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  { <span style=color:#75715e>//scope 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> b<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    { <span style=color:#75715e>//scope 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>int</span> c<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a: %d  b: %d  c: %d glo: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,a,b,c,glo );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a: %d  b: %d  c: %d glo: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,a,b,c,glo );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a: %d  b: %d  c: %d glo: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,a,b,c,glo );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이제 결과를 예상해 보자. 여태 배운 대로 라면 Inner scope 에서 선언된 식별자는</p><p>outer scope에서 사용할수 없다. 그렇다면 scope 2 에서는 scope3 의 정수형 식별자</p><p>c를 사용할수 없고, scope 1 에서는 정수형 식별자 b,c를 사용할수 없다.</p><p>그럼 결과를 보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>test.c:<span style=color:#ae81ff>12</span><span style=color:#f92672>:</span><span style=color:#ae81ff>48</span><span style=color:#f92672>:</span> error: use of undeclared identifier <span style=color:#e6db74>&#39;c&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a: %d  b: %d  c: %d glo: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,a,b,c,glo );
</span></span><span style=display:flex><span>                                               <span style=color:#f92672>^</span>
</span></span><span style=display:flex><span>test.c:<span style=color:#ae81ff>14</span><span style=color:#f92672>:</span><span style=color:#ae81ff>42</span><span style=color:#f92672>:</span> error: use of undeclared identifier <span style=color:#e6db74>&#39;b&#39;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a: %d  b: %d  c: %d glo: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,a,b,c,glo );
</span></span><span style=display:flex><span>                                         <span style=color:#f92672>^</span>
</span></span><span style=display:flex><span>test.c:<span style=color:#ae81ff>14</span><span style=color:#f92672>:</span><span style=color:#ae81ff>44</span><span style=color:#f92672>:</span> error: use of undeclared identifier <span style=color:#e6db74>&#39;c&#39;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a: %d  b: %d  c: %d glo: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,a,b,c,glo );
</span></span></code></pre></div><p>당연히 outer scope에서 inner scope의 식별자를 사용하는것은 불가능하다.</p><p>때문에 scope 2 에서는 scope 3 의 식별자를 사용할수 없고,</p><p>scope 1 에서는 scope 2, scope 3 의 식별자를 사용할수 없다.</p><p><code>C99</code> 표준에 서는 Scope 에 대해 다음과 같이 정의하고 있다.</p><blockquote><p>If so, the scope of one entity (the inner scope) will be a strict subset of the scope of the other entity (the outer scope).</p><p>Within the inner scope, the identifier designates the entity declared in the inner scope; the entity declared in the outer scope is hidden (and not visible) within the inner scope.</p></blockquote><h4 id=valid-scope>Valid scope</h4><p>같은 이름과 형식(Same entities)의 식별자 들은 다른 scope에서 사용되거나,</p><p>다른 파일(Different name space)에서 사용되어야 한다.</p><h4 id=variety-of-identifier>Variety of Identifier</h4><p>각 종류의 식별자는 그 자체의 scope를 가진다.</p><h5 id=function--함수-내부에서의-식별자>function : 함수 내부에서의 식별자</h5><p>function은 자체의 code block <code>{}</code> 안에서 선언된 식별자는</p><p>해당 scope안에서만 사용될수 있으며, global, static 의 속성이 없으면,</p><p>해당 scope 밖의 식별자를 사용할수 없다.</p><h5 id=function-prototype--함수-선언-parameter에서의-식별자>function prototype : 함수 선언 parameter에서의 식별자</h5><p>예를 들어 fuction을 선언 하고 사용 하기 위해선</p><p>전처리 부분에 function에 대한 정보를 알려줘야 한다.</p><p>예제를 보자</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a,<span style=color:#66d9ef>int</span> b); <span style=color:#75715e>// Function prototype
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#a6e22e>add</span>(a,a));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> a<span style=color:#f92672>+</span>b;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>function prototype 안에서의 <code>int a</code>와 main함수 scope안의 <code>int a</code> 는</p><p>중복 되지만 문제 되지 않는 이유는, 서로 다른 inner scope이기 때문에</p><p>서로 영향을 주지 않는다.</p><h5 id=file--서로-다른-파일내부의-식별자>file : 서로 다른 파일내부의 식별자</h5><h5 id=block--code-block내의-식별자>block : code block내의 식별자</h5><p>file scope 와 block 은 다음 예제를 보고 이해해 보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span> <span style=color:#75715e>//In add.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> test;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a,<span style=color:#66d9ef>int</span> b); <span style=color:#75715e>// Function prototype
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() <span style=color:#75715e>//main도 main함수의 식별자 이다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>//main 함수 code block안에 있는 정수형 식별자 i이다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 즉 main function 안에 존재 하는 정수형 식별자 이다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> result<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    { <span style=color:#75715e>// code block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>int</span> b<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;i+b: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,i<span style=color:#f92672>+</span>b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> <span style=color:#a6e22e>add</span>(i,i); <span style=color:#75715e>//add도 add함수의 식별자 이름이다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d&#34;</span>,result); <span style=color:#75715e>//printf 도 printf함수의 식별자
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d&#34;</span>,test); 
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b){ <span style=color:#75715e>// add function내부에서 사용하는 함수 a,b 이다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> a<span style=color:#f92672>+</span>b; 
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>//In sub.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//sub.c로 건너 오면 같은 이름의 식별자도 다른 name space에 존재하기 때문에
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 서로 영향을 주지 안는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; <span style=color:#75715e>//여기에 왜 static을 붙였을까?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> test<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sub</span>(<span style=color:#66d9ef>int</span> a,<span style=color:#66d9ef>int</span> b);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// add.c를 벗어난 다른 name space에서 사용된 같은 이름의 식별자이다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    result <span style=color:#f92672>=</span> <span style=color:#a6e22e>sub</span>(i,i);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d&#34;</span>,result);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a<span style=color:#f92672>-</span>b;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>위의 코드를 살펴 보면 특이 부분이 있다.</p><h5 id=static>static</h5><p>add.c 와 sub.c의 전역 변수중에 이름이 같은게 있다.</p><p>두변수의 이름은 모두 result 이다. 하지만 해당 코드들은 실행시 에러가 발생하지 않는다.</p><p>왜일까?</p><p>예상 대로 라면 같은 이름의 전역변수는 data segment에서 충돌될것이다.</p><p>하지만 전역변수에 staitc을 붙여 주면, 해당 전역 변수는</p><p>해당 파일의 file scope를 벗어나지 못한다.</p><p>때문에 sub.c의 result 는 sub file의 file scope 가 끝남과 동시에</p><p>메모리에서 해제 된다.</p><h5 id=extern>extern</h5><p>add.c 를 보면 <code>extern int test</code> 를 하고 있다.</p><p>뭘까? test 식별자는 add.c file scope 내에는 존재하지 않는다.</p><p>하지만 sub.c 를 보면 전역 변수로 <code>int test=100</code> 이 존재 한다.</p><p>그럼 이제 어느정도 감이 왔을겄이다.</p><p>extern은 file scope를 벗어나서 다른 file scope내에 있는</p><p>전역 변수를 사용하고자 할때 쓰는것.</p><blockquote><p>extren 은 다른 file scope 의 전역 변수의 사용을 가능케 한다.</p></blockquote><p>그럼 이제 예시를 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>//t1.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;t.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> test;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,test );
</span></span><span style=display:flex><span>  test<span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,test );
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>add</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//t2.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;t.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> test<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> i){
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,test );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//t.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>();
</span></span></code></pre></div><p>t1.c 는 t2.c 의 test를 가져 와서 출력후 1증가 한후 다시 출력해준다.</p><p>그리고 add 함수를 호출하는데, 이 함수는 t2.c에 있다.</p><p>그럼 t1.c에서 1을 증가 시켰던 test값이 t2.c에서 그대로 적용되는지 확인해 보는 예제이다.</p><p>그럼 결과를 살펴 보자</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>101</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>101</span>
</span></span></code></pre></div><p>물론 t1.c에서 증가 시켰던 test의 값이 t2.c에서도 그대로 적용되었다.</p><p>이러한 현상을 <code>linkage</code> 라고 한다.</p><p>메모리에는 어떻게 저장되어 있을까?</p><p><img src=/posts/study/sub-programming-language/system-programming-ftw-implementation/images/image-20180713142020491.png alt=image-20180713142020491></p><p>data segment 에 저장되어 있다.</p><p>extern으로 선언자를 지정해도 결국 초기화된 전역 변수 이므로 data segment에 저장된다.</p><p>이제 scope에 대해 어느정도 이해를 했을 것이다.</p><p>추후 내용에 <code>Parameter</code> 와 <code>Argument</code> 에 대한 내용이 나온다.</p><p>이둘의 관계처럼 선언자와 식별자의 관계는 중요하다.</p><h2 id=상수-변수>상수, 변수</h2><p>변수(Variable) : 정수, 실수, 문자, 문자열 등의 형태를 갖춘 가변 데이터.</p><blockquote><p>변수는 두가지 특징을 갖는다.</p><p>Scope - 특정 code block 안에서 실행, 참조된다.</p><p>Life time - 특정 code block안에서 존재하고 벗어나면 소멸 한다</p></blockquote><ol><li><p>일반 변수</p><p>일반적으로 사용하는 자료형에 해당하는 대입 변수이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>//일반 변수 = 데이터
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> b<span style=color:#f92672>=</span><span style=color:#ae81ff>3.2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> p<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;a&#39;</span>;
</span></span></code></pre></div></li><li><p>포인터 변수</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> temp_int<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> temp_d<span style=color:#f92672>=</span><span style=color:#ae81ff>3.4</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//포인터 변수 = 주소
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>a<span style=color:#f92672>=&amp;</span>temp_int;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>c<span style=color:#f92672>=&amp;</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#f92672>*</span>b<span style=color:#f92672>=&amp;</span>temp_d;
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;abc&#34;</span>;
</span></span></code></pre></div></li></ol><ul><li><p>상수(Constant) : 값이 바뀌지 않는 데이터를 상수라 한다.</p><ol><li><p>변수 상수화</p><p>변수 앞에 const를 붙여주면 상수가 된다.</p><p>const int a; => 상수로 정해진 변수는 값을 바꾸는것이 불가</p></li><li><p>매크로를 통한 상수화</p><p><code># define</code> 을 통해서 상수를 만들수 있다. 매크로는 전처리기에 의해 변환 되고</p><p>전역변수 처럼 사용 가능 하다. 위치는 헤더 파일 제일 밑에 사용해주면된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define pi 3.14
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define poweroftwo 2
</span></span></span></code></pre></div></li></ol><p>ex) 정수 상수 => -2,-1,0,1,2,3&mldr;.</p><p>​ 실수 상수 => -1.2, -0.2231, 3.14&mldr;</p><p>​ 문자 상수 => &lsquo;1&rsquo;, &lsquo;2&rsquo; ,&lsquo;ㄱ&rsquo;,&lsquo;A&rsquo;,&lsquo;a&rsquo;&mldr;</p><p>​ 문자열 상수 => &ldquo;abc&rdquo;, &ldquo;ABC&rdquo;&mldr;</p><ol><li><p>정수형 상수의 컴파일후의 비트 형태</p><p>정수형 상수는 컴파일되면 4바이트 크기의 2진수 형태로 변환 된다.</p><p>예를 들어 정수 13이 컴파일 되면, 나머지 비트는 0으로 채워 지게 됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ae81ff>0000</span> <span style=color:#ae81ff>0000</span>  <span style=color:#ae81ff>0000</span> <span style=color:#ae81ff>0000</span>  <span style=color:#ae81ff>0000</span> <span style=color:#ae81ff>0000</span>  <span style=color:#ae81ff>0000</span> <span style=color:#ae81ff>1101</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;--</span>MSB                              LSB<span style=color:#f92672>--&gt;</span>
</span></span></code></pre></div><p>여기서 중요한 개념이 나옵니다. MSB와 LSB가 무었인가</p><p>MSB는 <code>Most significant bit</code> 라 하며 가장 왼쪽의 비트는 전체 값에서 가장 큰 비중을 차지한다.</p><p>LSB는 <code>Least significant bit</code> 라 하며 가장 오른쪽의 비트는 전체 값에서 가장 작은 비중을 차지한다.</p><p>예를 들어,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ae81ff>1000</span> <span style=color:#ae81ff>0000</span>(<span style=color:#ae81ff>128</span>)  <span style=color:#f92672>&gt;</span>  <span style=color:#ae81ff>0111</span> <span style=color:#ae81ff>1111</span>(<span style=color:#ae81ff>127</span>)
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>극단</span> <span style=color:#960050;background-color:#1e0010>적인</span> <span style=color:#960050;background-color:#1e0010>예로</span> <span style=color:#ae81ff>128</span><span style=color:#960050;background-color:#1e0010>과</span> <span style=color:#ae81ff>127</span><span style=color:#960050;background-color:#1e0010>의</span> <span style=color:#960050;background-color:#1e0010>차이를</span> <span style=color:#960050;background-color:#1e0010>보면된다</span>.
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>뇌피셜로는</span> <span style=color:#960050;background-color:#1e0010>비트가</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>인</span> <span style=color:#960050;background-color:#1e0010>비트가</span> <span style=color:#960050;background-color:#1e0010>많을수록</span> <span style=color:#960050;background-color:#1e0010>숫자가</span> <span style=color:#960050;background-color:#1e0010>크다</span>.
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>물론</span> <span style=color:#960050;background-color:#1e0010>맞는</span> <span style=color:#960050;background-color:#1e0010>말이지만</span> <span style=color:#960050;background-color:#1e0010>모든경우에</span> <span style=color:#960050;background-color:#1e0010>해당되지는</span> <span style=color:#960050;background-color:#1e0010>안는다</span>.
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>위의</span> <span style=color:#960050;background-color:#1e0010>예처럼</span> <span style=color:#960050;background-color:#1e0010>오른쪽</span> <span style=color:#ae81ff>7</span><span style=color:#960050;background-color:#1e0010>비트가</span> <span style=color:#960050;background-color:#1e0010>전부</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>인</span> <span style=color:#960050;background-color:#1e0010>값보다</span> <span style=color:#960050;background-color:#1e0010>가장</span> <span style=color:#960050;background-color:#1e0010>왼쪽</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>비트가</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>인</span> <span style=color:#960050;background-color:#1e0010>값이</span> <span style=color:#960050;background-color:#1e0010>크다</span>.
</span></span></code></pre></div><p>그렇다면, 비트가 큰값으로 움직일때는 MSB의 움직임을 보면될것이다. 만약 작은 단위로</p><p>비트가 움직여야 한다면, LSB를 보면 되는데 이때 한가지 예를 살펴봐야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>(<span style=color:#ae81ff>0x8E</span>)<span style=color:#ae81ff>1000</span> <span style=color:#ae81ff>1101</span>(<span style=color:#ae81ff>141</span>)   <span style=color:#f92672>--&gt;</span>   (<span style=color:#ae81ff>0x8D</span>)<span style=color:#ae81ff>1000</span> <span style=color:#ae81ff>1110</span>(<span style=color:#ae81ff>142</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>가장</span> <span style=color:#960050;background-color:#1e0010>왼쪽</span> LSB의 <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>비트</span> <span style=color:#960050;background-color:#1e0010>움직임을</span> <span style=color:#960050;background-color:#1e0010>보일때</span> Niddle단위로 <span style=color:#960050;background-color:#1e0010>비트가</span> <span style=color:#960050;background-color:#1e0010>이동한다고</span> <span style=color:#960050;background-color:#1e0010>한다</span>.
</span></span></code></pre></div></li><li><p>실수형 상수의 컴파일후의 비트 형태</p><p>single, double, quad 세가지 형태가 있고, 그중에서 double형태를 살펴본다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#ae81ff>0</span>          <span style=color:#ae81ff>00000000000</span>      <span style=color:#ae81ff>00000.</span>..       
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>부호비트</span>(<span style=color:#ae81ff>1</span>)   <span style=color:#960050;background-color:#1e0010>지수</span> <span style=color:#960050;background-color:#1e0010>저장</span> <span style=color:#960050;background-color:#1e0010>비트</span>(<span style=color:#ae81ff>11</span>)	  <span style=color:#960050;background-color:#1e0010>소수</span> <span style=color:#960050;background-color:#1e0010>저장</span> <span style=color:#960050;background-color:#1e0010>비트</span>(<span style=color:#ae81ff>52</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>8</span>byte(<span style=color:#ae81ff>64</span>bit) 
</span></span><span style=display:flex><span> <span style=color:#75715e>//소소부
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>1</span>  ...
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span><span style=color:#f92672>^-</span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>^-</span><span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>^-</span><span style=color:#ae81ff>3</span> ...
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>위의</span> <span style=color:#960050;background-color:#1e0010>예시처럼</span> <span style=color:#960050;background-color:#1e0010>소수부는</span> <span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>의</span> <span style=color:#f92672>-</span>n제곱의 <span style=color:#960050;background-color:#1e0010>형태를</span> <span style=color:#960050;background-color:#1e0010>띈다</span>.
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>때문에</span> <span style=color:#960050;background-color:#1e0010>소수르</span> <span style=color:#960050;background-color:#1e0010>사용한</span> <span style=color:#960050;background-color:#1e0010>계산은</span> <span style=color:#960050;background-color:#1e0010>정확하지</span> <span style=color:#960050;background-color:#1e0010>안을수</span> <span style=color:#960050;background-color:#1e0010>있다</span>.
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span><span style=color:#f92672>^-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#960050;background-color:#1e0010>이고</span> <span style=color:#ae81ff>0.5</span><span style=color:#960050;background-color:#1e0010>이다</span>.
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span><span style=color:#f92672>^-</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>/</span><span style=color:#ae81ff>4</span> <span style=color:#960050;background-color:#1e0010>이고</span> <span style=color:#ae81ff>0.25</span><span style=color:#960050;background-color:#1e0010>이다</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span><span style=color:#f92672>^-</span><span style=color:#ae81ff>3</span> <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>/</span><span style=color:#ae81ff>8</span> <span style=color:#960050;background-color:#1e0010>이고</span> <span style=color:#ae81ff>0.125</span><span style=color:#960050;background-color:#1e0010>이다</span>.
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>소수부분이</span> <span style=color:#ae81ff>5</span><span style=color:#960050;background-color:#1e0010>의</span> <span style=color:#960050;background-color:#1e0010>나머지</span> <span style=color:#960050;background-color:#1e0010>연산으로</span> <span style=color:#960050;background-color:#1e0010>처리</span> <span style=color:#960050;background-color:#1e0010>되는점을</span> <span style=color:#960050;background-color:#1e0010>보면</span>, <span style=color:#ae81ff>0.3</span> <span style=color:#960050;background-color:#1e0010>같은</span> <span style=color:#960050;background-color:#1e0010>표현은</span> <span style=color:#960050;background-color:#1e0010>다루기</span> <span style=color:#960050;background-color:#1e0010>힘들다</span>.
</span></span></code></pre></div></li></ol></li></ul><h2 id=강제-형변환-vs-자동-형변환>강제 형변환 vs 자동 형변환</h2><ul><li><p>자동 형변환</p><p>자동 형변환은 더 작은 자료형에서 더큰 자료형으로 assign할때 발생.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>,b<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> b<span style=color:#f92672>=</span>a<span style=color:#f92672>/</span>b;
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%f</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,b);
</span></span><span style=display:flex><span><span style=color:#75715e>//실행결과
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>4.000000</span>
</span></span></code></pre></div><p>우리가 원하는 값은 4였을 터이지만 실제 출력값은 4.000000이 나온다.</p><p>double은 8바이트를 할당하고 지수부분에 11비트 소수부분이 52비트를 저장한다.</p><p>때문에 지수부분 4와 소수부분 52비트 즉 6바이트 0.000000 이기 때문에</p><p>소수점 밑으로 6자리를 표기한다.</p></li><li><p>강제 형변환</p><p>위와 같은 경우에서 원하는 값인 2로 표기할수도 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d&#34;</span>,(<span style=color:#66d9ef>int</span>)b);
</span></span><span style=display:flex><span><span style=color:#75715e>//실행결과
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p>물론 강제 형변환은 포인터 에서도 많이 쓰인다.</p><p><a href>함수 포인터</a>, <a href=/study/lecture0615/#1byte-access>byte access</a> 를 참고.</p></li></ul><h2 id=전달-인자argument와-매개변수parapeter>전달 인자(Argument)와 매개변수(Parapeter)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span>   <span style=color:#f92672>*</span>a  <span style=color:#f92672>=</span>  <span style=color:#f92672>&amp;</span>temp;
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>매개변수</span>   <span style=color:#960050;background-color:#1e0010>전달인자</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>a){}
</span></span><span style=display:flex><span>         <span style=color:#960050;background-color:#1e0010>매개변수</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>add</span>(<span style=color:#f92672>&amp;</span>temp);
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>전달인자</span>
</span></span></code></pre></div><h2 id=little-and-big-endian>LIttle and Big Endian</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>0</span>x <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span>
</span></span><span style=display:flex><span>   Little    Big
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___01___<span style=color:#f92672>|</span>___00___<span style=color:#f92672>|</span> <span style=color:#ae81ff>0x7fff2ab9</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___00___<span style=color:#f92672>|</span>___00___<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___00___<span style=color:#f92672>|</span>___00___<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___00___<span style=color:#f92672>|</span>___01___<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>________<span style=color:#f92672>|</span>________<span style=color:#f92672>|</span>
</span></span></code></pre></div><p>시스템마다 little endian, big endian 두가지 방법중 하나를 채택한다.</p><p>하지만 다양한 종류의 컴퓨터들끼리 통신을 해야 하는데, 이때 데이터를 읽어서 저장하는 방법이</p><p>다르다면 문제가 생긴다 때문에, 한가지로 통일해 줘야 한다.</p><p>이떄 사용 되는 방법이 <a href=/study/lecture0615/#1byte-access>Byte Access</a>이다</p><h2 id=digital-logic-circuitdld>Digital logic circuit(DLD)</h2><h2 id=bitwise>Bitwise</h2><ul><li><p>특정 비트 on/off</p><p>예를들어 Led의 한부분을 껏다 켯다 하는 동작이 발생할수도 있다.</p><p>LED와 연결되어 있는 특정 주소의 값에 한 비트를 on/off해야 동작 할때</p><p>다음과 같은 비트 연산으로 수행 가능하다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>res <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>0</span>x <span style=color:#ae81ff>1111</span> <span style=color:#ae81ff>0111</span>
</span></span><span style=display:flex><span>res<span style=color:#f92672>&amp;=~</span>(<span style=color:#ae81ff>0x01</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0111</span> <span style=color:#ae81ff>1111</span> (<span style=color:#f92672>~</span>res)
</span></span><span style=display:flex><span><span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1111</span> <span style=color:#ae81ff>0111</span> (res)
</span></span><span style=display:flex><span>_____________
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0111</span> <span style=color:#ae81ff>0111</span> <span style=color:#f92672>=&gt;</span> <span style=color:#960050;background-color:#1e0010>가장</span> <span style=color:#960050;background-color:#1e0010>오른쪽</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>비트만</span> off가 <span style=color:#960050;background-color:#1e0010>되었다</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>이처럼</span> <span style=color:#960050;background-color:#1e0010>특정</span> <span style=color:#960050;background-color:#1e0010>비트를</span> on<span style=color:#f92672>/</span>off할때에 <span style=color:#f92672>~</span>(not)<span style=color:#960050;background-color:#1e0010>과</span> <span style=color:#f92672>&amp;</span>(and)<span style=color:#960050;background-color:#1e0010>연산이</span> <span style=color:#960050;background-color:#1e0010>필요하다</span>.
</span></span></code></pre></div></li></ul><h2 id=basic-of-loop>Basic of Loop</h2><p>프로그래밍중에 실수와 의도에 의해서 무한 루프가 발생하거나 써야 하는 일이 있다.</p><ol><li><p>의도치 않은 무한 루프</p><p>대부분 세미 콜론이나, 조건식을 잘못 써서 발생한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>//case1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> val<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span>(val<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>5</span>); <span style=color:#f92672>=&gt;</span> while문의 <span style=color:#960050;background-color:#1e0010>내용이</span> <span style=color:#960050;background-color:#1e0010>시작하기</span> <span style=color:#960050;background-color:#1e0010>전에</span> <span style=color:#960050;background-color:#1e0010>세미콜론을</span> <span style=color:#960050;background-color:#1e0010>사용하였다</span>.
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>결과는</span> <span style=color:#960050;background-color:#1e0010>물론</span> <span style=color:#960050;background-color:#1e0010>무한</span> <span style=color:#960050;background-color:#1e0010>루프이다</span>.
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#960050;background-color:#1e0010>문의</span> <span style=color:#960050;background-color:#1e0010>조건식을</span> <span style=color:#960050;background-color:#1e0010>잘못</span> <span style=color:#960050;background-color:#1e0010>적용</span> <span style=color:#960050;background-color:#1e0010>하였고</span> <span style=color:#960050;background-color:#1e0010>루프에</span> <span style=color:#960050;background-color:#1e0010>빠지게</span> <span style=color:#960050;background-color:#1e0010>될텐데</span>,
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#960050;background-color:#1e0010>문의</span> <span style=color:#960050;background-color:#1e0010>내용이</span> <span style=color:#960050;background-color:#1e0010>시작하기</span> <span style=color:#960050;background-color:#1e0010>전에</span> <span style=color:#960050;background-color:#1e0010>세미</span> <span style=color:#960050;background-color:#1e0010>콜론으로</span> <span style=color:#960050;background-color:#1e0010>마무리</span> <span style=color:#960050;background-color:#1e0010>했다</span>.
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>때문에</span> printf <span style=color:#960050;background-color:#1e0010>는</span> <span style=color:#66d9ef>while</span> <span style=color:#960050;background-color:#1e0010>문의</span> <span style=color:#960050;background-color:#1e0010>무한</span> <span style=color:#960050;background-color:#1e0010>루프</span> <span style=color:#960050;background-color:#1e0010>때문에</span> <span style=color:#960050;background-color:#1e0010>출력이</span> <span style=color:#960050;background-color:#1e0010>되질</span> <span style=color:#960050;background-color:#1e0010>않는다</span>.
</span></span><span style=display:flex><span><span style=color:#75715e>//case2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> val<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(val<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;val<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>5</span>;val<span style=color:#f92672>++</span>); <span style=color:#f92672>=&gt;</span> for문의 <span style=color:#960050;background-color:#1e0010>내용이</span> <span style=color:#960050;background-color:#1e0010>시작도</span> <span style=color:#960050;background-color:#1e0010>전에</span> <span style=color:#960050;background-color:#1e0010>세미콜론이</span> <span style=color:#960050;background-color:#1e0010>찍혔다</span>.
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;aa</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>이번엔</span> <span style=color:#960050;background-color:#1e0010>어떨까</span><span style=color:#f92672>?</span> aa가 <span style=color:#ae81ff>5</span><span style=color:#960050;background-color:#1e0010>번</span> <span style=color:#960050;background-color:#1e0010>찍히는가</span><span style=color:#f92672>?</span> <span style=color:#960050;background-color:#1e0010>아니다</span>.
</span></span><span style=display:flex><span>for문의 <span style=color:#960050;background-color:#1e0010>내용이</span> <span style=color:#960050;background-color:#1e0010>시작도전에</span> <span style=color:#960050;background-color:#1e0010>세미콜론이</span> <span style=color:#960050;background-color:#1e0010>있기</span> <span style=color:#960050;background-color:#1e0010>때문에</span>, for문만 <span style=color:#ae81ff>5</span><span style=color:#960050;background-color:#1e0010>번</span> <span style=color:#960050;background-color:#1e0010>돌아가고나서</span>
</span></span><span style=display:flex><span>printf <span style=color:#960050;background-color:#1e0010>는</span> <span style=color:#960050;background-color:#1e0010>한번만</span> <span style=color:#960050;background-color:#1e0010>사용된다</span>. <span style=color:#960050;background-color:#1e0010>즉</span> aa는 <span style=color:#960050;background-color:#1e0010>한번만</span> <span style=color:#960050;background-color:#1e0010>출력되는것</span><span style=color:#f92672>!!</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>그럼</span> <span style=color:#960050;background-color:#1e0010>중괄호</span>(<span style=color:#960050;background-color:#1e0010>&#39;</span>{}<span style=color:#960050;background-color:#1e0010>&#39;</span>)<span style=color:#960050;background-color:#1e0010>의</span> <span style=color:#960050;background-color:#1e0010>역할은</span> <span style=color:#960050;background-color:#1e0010>뭘까</span><span style=color:#f92672>?</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>보통</span> <span style=color:#960050;background-color:#1e0010>중괄호는</span> <span style=color:#960050;background-color:#1e0010>코드의</span> <span style=color:#960050;background-color:#1e0010>영역을</span> <span style=color:#960050;background-color:#1e0010>나타낸다</span>.
</span></span></code></pre></div></li><li><p>의도한 루프</p><p>Firmware 등의 기본 동작에 필요한 경우가 있다. 혹은 지연 시간을 위해 고의적으로 넣는 경우도</p><p>있는데, 지금은 펌웨어에서 필요로 하는 Polling 방식에 대해 기술해 보려 한다.</p><ul><li><p>Polling</p><p>폴링방식은 하나의 프로그램에서 상태를 주기적으로 체크하여, 조건에 해당될때 송수신하는 목적이다.</p><p>예를 들어 보자, 세탁기 같은 내장프로그램을 봤을때, 시작과 종료 후에 다시 시작을 눌러도</p><p>기계는 작동한다. 이는 폴링 방식에 의해서 주기적으로 루프를 돌고 있기 때문이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>while</span>(<span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>조건</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>조건</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>조건</span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>프로그램은</span> <span style=color:#960050;background-color:#1e0010>계속해서</span> <span style=color:#960050;background-color:#1e0010>주기적으로</span> <span style=color:#960050;background-color:#1e0010>조건이</span> <span style=color:#960050;background-color:#1e0010>만족한</span> <span style=color:#960050;background-color:#1e0010>명령을</span> <span style=color:#960050;background-color:#1e0010>수행후</span> <span style=color:#960050;background-color:#1e0010>다시</span> <span style=color:#66d9ef>while</span> <span style=color:#960050;background-color:#1e0010>문</span> <span style=color:#960050;background-color:#1e0010>의</span> <span style=color:#960050;background-color:#1e0010>처음으로</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>돌아와서</span> <span style=color:#960050;background-color:#1e0010>처리한다</span>.
</span></span></code></pre></div></li><li><p>Interrupt</p><p>인터럽트 방식은 특정 이벤트가 발생했을때 동작을 멈추고 해당 이벤트를 처리하는것</p><p>주로 OS를 대표적인 예로 들수 있다. 만약 종료라는 이벤트가 발생한다면, cpu는 그즉시</p><p>모든 연산을 멈추고 종료를 처리한다.</p><p>물론 인터럽트 방식은 예기치 못한 상황에 대비할때 좋은 방법이다.</p></li></ul></li></ol><h2 id=array>Array</h2><p>배열은 자료형의 집합이라고 생각할수 있다. 배열은 메모리 Stack 에 할당되며, main부분에 사용된</p><p>배열은 프로그램 시작에 생성되고 종료시 삭제 된다. 하지만 함수 부분에서 사용한 배열은 함수 종료와 함께 사라진다. 때문에 동적할당의 필요성이 대두 될때가있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> arr[<span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>여기서</span> <span style=color:#66d9ef>int</span> <span style=color:#960050;background-color:#1e0010>는</span> <span style=color:#960050;background-color:#1e0010>배열의</span> <span style=color:#960050;background-color:#1e0010>자료형이고</span>
</span></span><span style=display:flex><span>arr은 <span style=color:#960050;background-color:#1e0010>배열명이다</span>.
</span></span></code></pre></div><p>이제는 배열을 활용하는법을 알아야 한다.</p><p>배열에 접근해서 직접 자료를 처리해서 프로그래밍을 해야한다.</p><p>때문에 배열에 접근 하는 방법을 알필요가 있다.</p><ol><li><p>직접 접근(Direct access)</p><p>배열에 직접적으로 접근하는 방법이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>arr[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,arr[<span style=color:#ae81ff>1</span>]);
</span></span></code></pre></div></li><li><p>간접 접근(Indirect access)</p><p>*(Asteric)에 관한 표현이 나오는데 이는 포인터의 개념이다.</p><p>해당 주소의 값을 가져 온다고 생각 하면 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#f92672>*</span>arr<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>*</span>(arr<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>))
</span></span></code></pre></div></li></ol><p>이제 배열을 사용하면서 주의해야 할사항들이 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> arr[<span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>     arr       <span style=color:#f92672>!=</span>    arr[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>배열의</span> <span style=color:#960050;background-color:#1e0010>시작</span> <span style=color:#960050;background-color:#1e0010>주소</span>       <span style=color:#960050;background-color:#1e0010>배열의</span> <span style=color:#ae81ff>0</span><span style=color:#960050;background-color:#1e0010>번째</span> <span style=color:#960050;background-color:#1e0010>값</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>arr      <span style=color:#f92672>==</span>   <span style=color:#f92672>&amp;</span>arr[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>배열의</span> <span style=color:#960050;background-color:#1e0010>시작</span> <span style=color:#960050;background-color:#1e0010>주소</span>       <span style=color:#960050;background-color:#1e0010>배열의</span> <span style=color:#ae81ff>0</span><span style=color:#960050;background-color:#1e0010>번째</span> <span style=color:#960050;background-color:#1e0010>주소</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>배열의</span> <span style=color:#960050;background-color:#1e0010>시작</span> <span style=color:#960050;background-color:#1e0010>주소는</span> <span style=color:#960050;background-color:#1e0010>배열의</span> <span style=color:#ae81ff>0</span><span style=color:#960050;background-color:#1e0010>번째</span> <span style=color:#960050;background-color:#1e0010>주소화</span> <span style=color:#960050;background-color:#1e0010>일치한다</span>
</span></span></code></pre></div><p>arr이라는 배열명은 수정 불가능한 포인터 상수이다.</p><p>만약 inr arr[5]; 선언후, arr의 주소가 0x2000번지 일때 0x3000번지로 수정하는것 불가!</p><p>배열은 한번 스택에 할당 되면 고정된다.</p><p>배열의 각 요소 들간의 차이는 배열의 자료형의 크기에 달려 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>arr[<span style=color:#ae81ff>0</span>]   <span style=color:#f92672>-&gt;</span>   arr[<span style=color:#ae81ff>1</span>]   <span style=color:#f92672>-&gt;</span>    arr[<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x0200</span>  <span style=color:#ae81ff>4</span>byte <span style=color:#ae81ff>0x0204</span>  <span style=color:#ae81ff>4</span>byte  <span style=color:#ae81ff>0x0208</span>
</span></span></code></pre></div><h2 id=shallow-copy얕은-복사-vs-deep-copy깊은-복사>Shallow copy(얕은 복사) vs Deep copy(깊은 복사)</h2><ul><li>Shallow copy(얕은 복사)</li><li>Deep copy(깊은 복사)</li></ul><h2 id=function>Function</h2><p>함수는 3가지 단계이자 요소가 필요하다.</p><ol><li><p>함수의 원형</p><p>main문 시작전에 전저리 부분 다음에 기술해줘야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>display</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a,<span style=color:#66d9ef>int</span> b);
</span></span></code></pre></div><p>위의 예시처럼 원형을 기술할 때에는 매개변수부분은 써줘도되고 안써줘도 된다.</p></li><li><p>함수의 호출</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>,b<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>display</span>();
</span></span><span style=display:flex><span>    res<span style=color:#f92672>=</span><span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#a6e22e>add</span>(a,b));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>함수의 정의</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>display</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>ptr,<span style=color:#66d9ef>int</span> idx){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>idx;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d has %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,i,<span style=color:#f92672>*</span>(ptr<span style=color:#f92672>+</span>i));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol><h2 id=pointer>Pointer</h2><p>포인터라 하면 c언어의 포기하는 break point일지도 모른다. 하지만 포인터를 활용 하지못한다면</p><p>다양항 프로그래밍이 불가능 하다 포인터 부분은 자다가도 벌떡 일어나서 정의할수 있어야한다.</p><blockquote><p>주소 연산자(&)</p></blockquote><p>&(Ampersand) 엔드 연산자, 주소연산자 등등으로 불린다. 정확한 명칭은 Ampersand이다.</p><p>주소 연산자는 해당 변수, 함수 등의 주소를 확인할수 있게 합니다.</p><p>주소에 대해 생소할수 있습니다. 프로그램 실행시에 컴파일러에 의해 메모리에 각 영역에 따른 변수나 함수 등이 할당됩니다. 첫번째 예는 변수 입니다.</p><ul><li><p>Local & Gloal Variable</p><p>Local Variable은 지역 변수라고도 하며, 해당 함수 범위 내에서만 사용할수 있는 변수입니다.</p><p>Global Variable은 전역 변수 라고도 하며, 코드 내의 그 어떤 부분에서도 사용할수 있습니다.</p><p>이제 두변수의 사용 예를 살펴보려 합니다.</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> global_b<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> local_a<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> global_a<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;In main funtion local variable local_a has %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,local_a );
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;In main funtion local variable local_a address %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>local_a );
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;In main funtion static global_a has %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,global_a );
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;In main funtion static global_a address %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>global_a );
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;In main funtion global variable global_b has %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,global_b );
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;In main funtion global variable global_b address %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>global_b );
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>local_func</span>(local_a,global_a);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>point_func</span>(<span style=color:#f92672>&amp;</span>local_a);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,local_a);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>local_func</span>(<span style=color:#66d9ef>int</span> a,<span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;In local funtion printf local_a has: %d address: %p</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>,a,<span style=color:#f92672>&amp;</span>a);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;In local funtion printf global_a has: %d address: %p</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>,b,<span style=color:#f92672>&amp;</span>b);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;In local funtion printf global_b has: %d address: %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>but not using parameter</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,global_b,<span style=color:#f92672>&amp;</span>global_b);
</span></span><span style=display:flex><span>    a<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a=10;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>local_a change 10 to 20 not using poiter</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>point_func</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p){
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>p<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>메인 함수에서 local_a와 global_a를 선합니다. 하지만 global_a는 앞에 static이 붙습니다.</p><p>왜일까요? 바로 전역 변수 처럼 사용하기 위합입니다. 변수 앞에 static을 붙이면 전역 변수 저장 영역인 data영역에 할당됩니다. 마치 전역변수 처럼요.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>In main funtion local variable local_a has <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>In main funtion local variable local_a address <span style=color:#ae81ff>0x7ffeed43898c</span>
</span></span><span style=display:flex><span>In main funtion <span style=color:#66d9ef>static</span> global_a has <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>In main funtion <span style=color:#66d9ef>static</span> global_a address <span style=color:#ae81ff>0x1027c801c</span>
</span></span><span style=display:flex><span>In main funtion global variable global_b has <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>In main funtion global variable global_b address <span style=color:#ae81ff>0x1027c8018</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#75715e>//into local_fun
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>In local funtion printf local_a has: <span style=color:#ae81ff>10</span> address: <span style=color:#ae81ff>0x7ffeed43894c</span>
</span></span><span style=display:flex><span>In local funtion printf global_a has: <span style=color:#ae81ff>20</span> address: <span style=color:#ae81ff>0x7ffeed438948</span>
</span></span><span style=display:flex><span>In local funtion printf global_b has: <span style=color:#ae81ff>10</span> address: <span style=color:#ae81ff>0x1027c8018</span>
</span></span><span style=display:flex><span>but not using parameter
</span></span><span style=display:flex><span>a<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>local_a change <span style=color:#ae81ff>10</span> to <span style=color:#ae81ff>20</span> not using pointer
</span></span><span style=display:flex><span><span style=color:#75715e>//end local_func
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>after local_func, a has <span style=color:#ae81ff>10</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>local_a passing by point_func
</span></span><span style=display:flex><span><span style=color:#75715e>//into point_func
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>In point_func change local_a <span style=color:#ae81ff>10</span> to <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//end point_func
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>after point_func, Now local_a has <span style=color:#ae81ff>100</span>
</span></span></code></pre></div><p>local_func에서 local_a의 값을 변화 시키려 했지만 메인 함수에서 local_a의 값을 출력해보니 그대로 입니다. 왜일까요?</p><p>local_fun는 전달 인자를 int a로 받았습니다. 이러한 매개변수는 값의 복사가 발생합니다.</p><p>바로 <code>call by value</code> 의 상황이죠. 즉, 메모리에 변수의 복사가 발생하고, 이 변수는 함수의 종료와</p><p>동시에 바로 삭제 됩니다.</p><h3 id=call-by-value>call by value</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> local_a<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> global_a<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>local_func</span>(local_a,global_a);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>local_func</span>(<span style=color:#66d9ef>int</span> a,<span style=color:#66d9ef>int</span> b){ <span style=color:#f92672>=&gt;</span> <span style=color:#960050;background-color:#1e0010>변수의</span> <span style=color:#960050;background-color:#1e0010>값을</span> <span style=color:#960050;background-color:#1e0010>함수의</span> <span style=color:#960050;background-color:#1e0010>변수로</span> <span style=color:#960050;background-color:#1e0010>복사하는것입니다</span>.
</span></span><span style=display:flex><span>    a<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>; <span style=color:#f92672>=&gt;</span><span style=color:#960050;background-color:#1e0010>함수</span> <span style=color:#960050;background-color:#1e0010>내부의</span> <span style=color:#960050;background-color:#1e0010>변수는</span> <span style=color:#960050;background-color:#1e0010>함수의</span> <span style=color:#960050;background-color:#1e0010>시작과</span> <span style=color:#960050;background-color:#1e0010>동시에</span> <span style=color:#960050;background-color:#1e0010>생성되고</span> <span style=color:#960050;background-color:#1e0010>종료와</span> <span style=color:#960050;background-color:#1e0010>함께</span> <span style=color:#960050;background-color:#1e0010>반환됩니다</span>.
</span></span><span style=display:flex><span>    b<span style=color:#f92672>=</span><span style=color:#ae81ff>400</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Call by value는 매개변수로 값을 받아와 함수의 메모리로 복사해오는것 입니다.</p><p>그래서 함수내부에서 아무리 값을 바꿔도, 실상은 함수로 복사된 값을 변환하는 것이므로,</p><p>본래의 전달인자로 들어온 변수는 그대로입니다.</p><p>그럼 본래 변수의 값을 바꾸려면 어떻게 해야할까요?</p><h3 id=call-by-referencecall-by-address>call by reference(call by address)</h3><p>사실 C에서는 Call by reference 가 완벽하게 작동하지는 않습니다.</p><p>아이라 폴과 알켈리의 <code>A Book on C</code> 에서 P.252 의 call by reference 를 언급하자면,</p><blockquote><p>How the used of addresses of variables as arguments to functions can produce</p><p>the effect of &ldquo;call by reference&rdquo;.</p></blockquote><p>라고 명시되어 있습니다.</p><p>다른 언어에서는 call by reference의 mechanism이 존재 하지만 C에서는 존재 하지 않습니다.</p><p>하지만 비슷한 동작을 할수 있게끔 만들어줄수는 있습니다. 일단 예제를 보죠.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>, b<span style=color:#f92672>=</span><span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a: %d  b: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,a,b);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>swap</span>(<span style=color:#f92672>&amp;</span>a,<span style=color:#f92672>&amp;</span>b);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;a: %d  b: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,a,b);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>swap</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>a, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>b){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> temp;
</span></span><span style=display:flex><span>    temp<span style=color:#f92672>=*</span>a;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>a<span style=color:#f92672>=*</span>b;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>b<span style=color:#f92672>=</span>temp; 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이전의 call by value에서는 함수에서의 값의 복사 때문에 본래의 변수의 값은 변하지 안았습니다.</p><p>근데 이번 함수 swap은 매개변수(int *a)가 포인터이며, 전달인자(&amp;a)를 변수의 주소를 받고있습니다.</p><p>결과는 어떨까요?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>a: <span style=color:#ae81ff>3</span>  b: <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span>a: <span style=color:#ae81ff>7</span>  b: <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>값의 변화가 있습니다. 뭘까요?</p><p>바로 call by reference의 효과 입니다. 변수의 주소를 전달 받아 직접 값을 바꾸는 것이죠.</p><p>하지만 <code>A Book on C</code>에서 언급했던 완벽한 call by reference가 아닌 이유가 여기있습니다.</p><p>사실상 주소를 전달받아 값을 바꾼 다는 것은, 주소의 값을 call by value한다는 것이죠.</p><p>잘 이해가 안가는데 다음 예제를 살펴보죠.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>//출처 : 나무위키
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testFunc</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> fptr) {
</span></span><span style=display:flex><span>    fptr <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> ptr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>num;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>*</span>ptr );
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>testFunc</span>(ptr);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>*</span>ptr );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>testFunc라는 함수는 포인터를 인자로 받아 포인터의 값을 NULL로 바꿉니다.</p><p>자 그러면 코드를 어떻게 동작을 할까요?</p><p>메인 함수에서 ptr은 num 의 주소를 갖고 있습니다. 그리고 그 주소에 대한 값을 testFunc에</p><p>전달 하고 있습니다. 그럼 testFunc를 완료 하고 나면 ptr에는 NULL이 저장 될테고,</p><p>더이상 num을 가르킬수 없습니다. 과연 결과도 그럴까요?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>12</span>
</span></span></code></pre></div><p>예상과는 다르게 num의 값은 변하지 안았습니다.</p><p>이게 뭘 뜻하는 걸까요?</p><p>C에서는 주소값을 전달 받아 해당 주소로 이동후 값을 변화 할수 있지만, 그 과정에서 정확히는</p><p>전달 인자로 포인터 변수를 전달한다. 즉, 포인터 변수 ptr을 전달 하므로 이는 <code>call by value</code></p><p>라고 할수 있다. 그러므로 C에서는 <code>call by reference</code>는 없다고 정의 할수 있다.</p><p>다시 말해 함수에 인자를 받아 인자값 자체를 변화 시키는 것은 불가능 하다, 하지만 인자값의 주소로 건너가 그 값을 바꾸는 것은 가능하다, 하지만 이것은 값의 의한 복사 <code>call by value</code> 이다.</p><p>하지만 <code>call by value</code> 로 전달하는 <code>value</code> 가 주소값이 이기 때문에 <code>call by value</code> 라고 부는것!!</p><p>결론은 <code>call by reference</code>가 아니라 <code>call by address</code> or <code>call by pointer</code></p><p>라고 불러야 한다.</p><p>그럼 진정한 call by reference는 어디에 존재하는 것이가?</p><p>바로 c++부터 그 개념이 등장한다.</p><h3 id=call-by-reference>call by reference</h3><p>c++ 에서는 참조 변수 라는 것이 존재한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>b<span style=color:#f92672>=</span>a;
</span></span></code></pre></div><p>c에서는 &(ampersand)는 주소 값의 반화을 의미했다. 하지만 c++에서는 참조 매개변수가 존재 하며</p><p>값을 복사 하는 <code>call by value</code> 가 아닌 주소 값을 받아와 참조에 의한 접근이 가능하다.</p><p>다음 c++ 예시를 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func1</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>q);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func2</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>q);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func3</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>q);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>point<span style=color:#f92672>=&amp;</span>a;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;a address: %p  value: %d </span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>a,a);
</span></span><span style=display:flex><span>    func1(<span style=color:#f92672>&amp;</span>a);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;After func1 a value: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,a);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>===================================</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;point address:%p  point has : %p  value: %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>point,point,<span style=color:#f92672>*</span>point );
</span></span><span style=display:flex><span>    func2(point);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;After func2 a value: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,a);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>===================================</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Now we declaration int &amp;ref_point=a</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>ref_point<span style=color:#f92672>=</span>a;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;point address:%p  point has : %p  value: %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>point,point,<span style=color:#f92672>*</span>point );
</span></span><span style=display:flex><span>    func3(ref_point);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;After func3 a value: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,a);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func1</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>q){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;In Func1</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Now we change value of a to 100</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>So q=20;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>if you think change the value?</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//q=20;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printf(<span style=color:#e6db74>&#34;q=20; is error occured</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;q address: %p  value: %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>q,<span style=color:#f92672>*</span>q);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;a address: %p  value: %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,q,<span style=color:#f92672>*</span>q);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func2</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>q){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;In Func2</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Now we change value of a to 100</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>So *q=100;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>if you think change the value?</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>q<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;q address: %p  value: %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>q,<span style=color:#f92672>*</span>q);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;a address: %p  value: %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,q,<span style=color:#f92672>*</span>q);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func3</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>q){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;In Func3</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Now we change value of a to 100</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>So *q=3000;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>if you think change the value?</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    q<span style=color:#f92672>=</span><span style=color:#ae81ff>3000</span>;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;q address: %p  value: %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>q,q);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>내용이 복잡하다. 우선 각 함수들이 뭘하는 지를 살펴보자.</p><p>fun1~3까지의 함수가 존재하는데,</p><p><code>func1</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>//일반 적인 c에서의 call by address의 예시이다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func1</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>q){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;In Func1</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Now we change value of a to 100</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>So q=20;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>if you think change the value?</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//q=20; =&gt; 진정한 call by reference가 되려면 주소로 받아온 값을 바꿀수 있어야한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printf(<span style=color:#e6db74>&#34;q=20; is error occured</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;q address: %p  value: %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>q,<span style=color:#f92672>*</span>q);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;a address: %p  value: %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,q,<span style=color:#f92672>*</span>q);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>func1은 매개변수로 포인터 변수 를 사용 하며, 전달 인자로 주소를받는다.</p><p>만약 q=20을 하면 어떻게 될까?</p><p>사실상 main함수에서 <code>int *point=&amp;a;</code> 라고 선언했다는 것은</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>//예를 들어 변수 q는 0x2000에 존재 하며 a변수는 0x1000에 있다고 치자.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>point <span style=color:#f92672>==</span> <span style=color:#f92672>&amp;</span>a <span style=color:#f92672>==</span><span style=color:#ae81ff>0x1000</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&amp;</span>point <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x2000</span>(address of q q변수의 <span style=color:#960050;background-color:#1e0010>주소</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>*</span>point <span style=color:#f92672>==</span> a(a의 <span style=color:#960050;background-color:#1e0010>값</span> <span style=color:#ae81ff>10</span>)
</span></span></code></pre></div><p>이제 위의 내용을 머리속에 넣고 정신 단디 차리고 하나씩 해석해 보자.</p><p>먼저 func1에에서 전달 인자로 &amp;a를 전달 했고 *q 포인터 변수로 받았다.</p><p>이때 무슨일이 생길까?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>//In func1
</span></span></span><span style=display:flex><span><span style=color:#75715e>//메인 함수에서 a의 주소를 전달 했다.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//그러면 func1함수에서는 함수 시작과 동시에 int *q에 대한 변수 공간을 생성한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//위에서 a변수의 주소는 0x1000이였다. 그렇다면 함수로 a의 주소를 전달하고 나서도
</span></span></span><span style=display:flex><span><span style=color:#75715e>//그래도 a의 변수를 참조하여 접근이 가능할까?
</span></span></span><span style=display:flex><span><span style=color:#75715e>//진정한 call by reference 라면 받아온 주소로 바로 접근이 가능해야할것이다.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//===============컴파일 결과==============
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>a address: <span style=color:#ae81ff>0x7ffee1f8173c</span>  value: <span style=color:#ae81ff>10</span> 
</span></span><span style=display:flex><span>In Func1
</span></span><span style=display:flex><span>Now we change value of a to <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>So q<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> you think change the value<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>q<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>; is error occured
</span></span><span style=display:flex><span>q address: <span style=color:#ae81ff>0x7ffee1f816e8</span>  value: <span style=color:#ae81ff>10</span> 
</span></span><span style=display:flex><span>a address: <span style=color:#ae81ff>0x7ffee1f8173c</span>  value: <span style=color:#ae81ff>10</span> 
</span></span><span style=display:flex><span>After func1 a value: <span style=color:#ae81ff>10</span>
</span></span></code></pre></div><p>결과를 살펴 보자.</p><p>우리가 원하는 결과는 받아온 a의 주소와 매개변수 q의 주소가 같아야한다.</p><p>근데 보아하니 주소값은 두개가 존재한다. 이건 뭘 뜻할까?</p><p>func1이 실행되는 순간 <code>int *q</code> 에 대한 변수 공간이 마련된다.</p><p>이곳은 주소는 <code>0x7ffee1f816e8</code> 이다. 그리고 해당 주소한에 들어있는 값이 <code>0x7ffee1f8173c(a의 주소)</code>이다.</p><p>즉 값에 의한 복사인 <code>call by value</code> 로 인해 a의 주소 값을 받아와 접근한다는것이다.</p><p>때문에 q안에는 a의 주소값인 <code>0x7ffee1f8173c</code> 이 들어 있고 ,</p><p><code>q=20;</code> 이라는 재할당을 한다는 것은 q가 갖고는 있는 값을 20 으로 바꾼 다는 것이고,</p><p>q는 포인터 변수 이기 때문에 20의 주소에 있는 값을 가져와야 한다고 해석한다.</p><p>하지만 마음대로 메모리를 접근할수는 없다 컴파일 단계에서</p><p>이런 위험한 코드는 막아 버리기때문에 에러를 토해낸다.</p><p>결국 func1은 <code>call by value</code> 에 의한 함수 내부의 포인터 변수 공간에</p><p>전달 인자로 받아온 a의 주소를 저장 하여 a의 값에 접근 한다는것이다.</p><p>진정한 <code>call by reference</code> 는 실패 했다.</p><p>그럼 이제 두번째 함수 <code>func2</code> 를 살펴보자.</p><p><code>func2</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func2</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>q){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;In Func2</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Now we change value of a to 100</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>So *q=100;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>if you think change the value?</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>q<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;q address: %p  value: %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>q,<span style=color:#f92672>*</span>q);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;a address: %p  value: %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,q,<span style=color:#f92672>*</span>q);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>사실상 func1과 별 차이가 없다. 하지만 func2에서는 a의 변수를 포인터로 접근하여</p><p>값을 변경하기 때문에 a값의 변화가 생긴다.</p><p>하지만 위에서 봤듯이 이는 <code>call by value</code> 에 의한 <code>call by reference</code> 를 흉내 낸것이다.</p><p>우리는 이러한 과정을 <code>call by address</code> or <code>call by pointer</code> 라고 부른다.</p><p>그럼 진정한 <code>call by reference</code> 는 어떻게 해야 볼수 있을까?</p><p>위에서 <code>데니스 리치</code> 의 말을 언급 하면 C에서는 <code>call by reference</code> 는 없다 .</p><p>하지만 C++에서는 참조 변수라는것이 존재한다.</p><p>이제 func3를 살펴 보자.</p><p><code>func3</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>ref_point<span style=color:#f92672>=</span>a;
</span></span><span style=display:flex><span>    func3(ref_point);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func3</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>q){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;In Func3</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Now we change value of a to 100</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>So *q=3000;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>if you think change the value?</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    q<span style=color:#f92672>=</span><span style=color:#ae81ff>3000</span>;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;q address: %p  value: %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,<span style=color:#f92672>&amp;</span>q,q);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>우리가 알던 C의 문법에서는 볼수 없는 변수 선언이 있다. 이게 뭘까 싶다.</p><p>일단 실행 결과를 살펴 보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#f92672>===================================</span>
</span></span><span style=display:flex><span>Now we declaration <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>ref_point<span style=color:#f92672>=</span>a
</span></span><span style=display:flex><span>ref_point address:<span style=color:#ae81ff>0x7ffeee79373c</span>  ref_point has : <span style=color:#ae81ff>100</span> 
</span></span><span style=display:flex><span>In Func3
</span></span><span style=display:flex><span>Now we change value of a to <span style=color:#ae81ff>3000</span>
</span></span><span style=display:flex><span>So q<span style=color:#f92672>=</span><span style=color:#ae81ff>3000</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> you think change the value<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>q address: <span style=color:#ae81ff>0x7ffeee79373c</span>  value: <span style=color:#ae81ff>3000</span> 
</span></span><span style=display:flex><span>After func3 a value: <span style=color:#ae81ff>3000</span>
</span></span></code></pre></div><p>정말 신박함의 극을 달린다 할수 있다. <code>int &amp;ref_point=a</code> 참조 변수에 a의 주소 값도 아닌</p><p>a를 할당 하고 있다. 그리고 ref_point의 주소를 출력해보니 ref_point의 별도의 변수 공간이 아닌</p><p>a의 주소를 출력하고 있다.</p><p>그럼 함수 안에서는 어떨까?</p><p>물론 q 변수에 대해서도 별도의 변수 공간을 할당하지 않는다.</p><p>함수내에서도 a의 주소 를 출력하고 있으며, q로 값을 3000으로 재할당한후,</p><p>함수가 종료되고 나서 a의 값을 출력해 보니 3000으로 바뀌어 있다.</p><p>진정한 <code>call by reference</code> 란 값에 의한 복사를 통해 변수에 접근하는 것이 아닌</p><blockquote><p>값의 복사 없이 변수 자체에 접근 할수 있어야 한다는 것</p></blockquote><p>그래서 데니스 리치는 <code>call by reference</code> 에 대해</p><blockquote><p>&mldr;&ldquo;call by reference&rdquo;&mldr;, in which the called routine has access to the original argument, not a local copy.</p></blockquote><p>&ldquo;호출 과정 내에서 지역 값의 복사 없이 원본 인자에 접근 할수 있어여하 한다&rdquo; 라고 말한 것이다.</p></div><div class="row ps-3 pe-3"><div class="col-md-6 share-buttons"><strong>Share on:</strong>
<a class="btn icon-button bg-facebook" href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fcodex-devlab.github.io%2fposts%2fstudy%2fsub-programming-language%2fsystem-programming-ftw-implementation%2f" target=_blank><i class="fab fa-facebook"></i>
</a><a class="btn icon-button bg-twitter" href="https://twitter.com/share?url=https%3a%2f%2fcodex-devlab.github.io%2fposts%2fstudy%2fsub-programming-language%2fsystem-programming-ftw-implementation%2f&text=C%ec%96%b8%ec%96%b4%20%ec%8a%a4%ed%84%b0%eb%94%94&via=CodeXlog" target=_blank><i class="fab fa-twitter"></i>
</a><a class="btn icon-button bg-linkedin" href="https://www.linkedin.com/shareArticle?url=https%3a%2f%2fcodex-devlab.github.io%2fposts%2fstudy%2fsub-programming-language%2fsystem-programming-ftw-implementation%2f&title=C%ec%96%b8%ec%96%b4%20%ec%8a%a4%ed%84%b0%eb%94%94" target=_blank><i class="fab fa-linkedin"></i>
</a><a class="btn icon-button" href="mailto:?subject=C%ec%96%b8%ec%96%b4%20%ec%8a%a4%ed%84%b0%eb%94%94&body=https%3a%2f%2fcodex-devlab.github.io%2fposts%2fstudy%2fsub-programming-language%2fsystem-programming-ftw-implementation%2f" target=_blank><i class="fas fa-envelope-open-text"></i></a></div><div class="col-md-6 btn-improve-page"><a href=https://github.com/codex-devlab/codex-devlab.github.io/edit/main/content/posts/study/sub-programming-language/system-programming-ftw-implementation/index.md title="Improve this page" target=_blank rel=noopener><i class="fas fa-code-branch"></i>
Improve this page</a></div></div><hr><div class="row next-prev-navigator"><div class="col-md-6 previous-article"><a href=/posts/study/sub-computer-science/system-programming-ftw-implementation/ title="시스템프로그래밍 FTW 구현" class="btn filled-button"><div><i class="fas fa-chevron-circle-left"></i> Prev</div><div class=next-prev-text>시스템프로그래밍 FTW 구현</div></a></div><div class="col-md-6 next-article"><a href=/posts/dev/sub-tips/ title=Tips class="btn filled-button"><div>Next <i class="fas fa-chevron-circle-right"></i></div><div class=next-prev-text>Tips</div></a></div></div><hr><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="codex-devlab-github-io",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div><a id=scroll-to-top class=btn type=button data-bs-toggle=tooltip data-bs-placement=left title="Scroll to top"><i class="fas fa-chevron-circle-up"></i></a></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center ps-3">Table of Contents</h5><hr><div class=toc><nav id=TableOfContents><ul><li><a href=#c언어>C언어</a><ul><li><a href=#소프트웨어-공학>소프트웨어 공학</a></li><li><a href=#cpu-구조>CPU 구조</a></li><li><a href=#폰노이만-구조최초의-컴퓨터-구조를-만듬>폰노이만 구조(최초의 컴퓨터 구조를 만듬)</a></li><li><a href=#c-메모리-구조>C 메모리 구조</a><ul><li><a href=#local-variables>local variables</a></li><li><a href=#global-variables>global variables</a></li><li><a href=#static-variables>static variables</a></li><li><a href=#auto-variables>auto variables</a></li><li><a href=#the-register-modifier>the register modifier</a></li><li><a href=#extern-variables>extern variables</a></li><li><a href=#const-variables>const variables</a></li><li><a href=#the-volatile-modifier>the volatile modifier</a></li></ul></li><li><a href=#컴파일-과정>컴파일 과정</a></li><li><a href=#c-concept>C Concept</a><ul><li><a href=#scope>scope</a><ul><li><a href=#declarator>Declarator</a></li><li><a href=#identifier>Identifier</a></li><li><a href=#visible>Visible</a></li><li><a href=#valid-scope>Valid scope</a></li><li><a href=#variety-of-identifier>Variety of Identifier</a><ul><li><a href=#function--함수-내부에서의-식별자>function : 함수 내부에서의 식별자</a></li><li><a href=#function-prototype--함수-선언-parameter에서의-식별자>function prototype : 함수 선언 parameter에서의 식별자</a></li><li><a href=#file--서로-다른-파일내부의-식별자>file : 서로 다른 파일내부의 식별자</a></li><li><a href=#block--code-block내의-식별자>block : code block내의 식별자</a></li><li><a href=#static>static</a></li><li><a href=#extern>extern</a></li></ul></li></ul></li></ul></li><li><a href=#상수-변수>상수, 변수</a></li><li><a href=#강제-형변환-vs-자동-형변환>강제 형변환 vs 자동 형변환</a></li><li><a href=#전달-인자argument와-매개변수parapeter>전달 인자(Argument)와 매개변수(Parapeter)</a></li><li><a href=#little-and-big-endian>LIttle and Big Endian</a></li><li><a href=#digital-logic-circuitdld>Digital logic circuit(DLD)</a></li><li><a href=#bitwise>Bitwise</a></li><li><a href=#basic-of-loop>Basic of Loop</a></li><li><a href=#array>Array</a></li><li><a href=#shallow-copy얕은-복사-vs-deep-copy깊은-복사>Shallow copy(얕은 복사) vs Deep copy(깊은 복사)</a></li><li><a href=#function>Function</a></li><li><a href=#pointer>Pointer</a><ul><li><a href=#call-by-value>call by value</a></li><li><a href=#call-by-referencecall-by-address>call by reference(call by address)</a></li><li><a href=#call-by-reference>call by reference</a></li></ul></li></ul></li></ul></nav></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-start"><div class="col-md-4 col-sm-12"><h5>Navigation</h5><ul><li class=nav-item><a class=smooth-scroll href=https://codex-devlab.github.io/#recent-posts>Recent Posts</a></li><li class=nav-item><a class=smooth-scroll href=/tags/>Tags</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contact me:</h5><ul><li><a href=mailto:codex.devlab@gmail.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>codex.devlab@gmail.com</span></a></li><li><a href=https://github.com/https://github.com/ehdwn1991 target=_blank rel=noopener><span><i class="fab fa-github"></i></span> <span>https://github.com/ehdwn1991</span></a></li><li><a href=https://www.linkedin.com/in/dongju-son target=_blank rel=noopener><span><i class="fab fa-linkedin"></i></span> <span>DongjuSon</span></a></li></ul></div></div></div><hr><div class=container><p id=disclaimer><strong>Liability Notice:</strong> This theme is under MIT license. So, you can use it for non-commercial, commercial, or private uses. You can modify or distribute the theme without requiring any permission from the theme author. However, the theme author does not provide any warranty or takes any liability for any issue with the theme.</p></div></footer><script src=/application.5c1b4fcf22483f6df2703ba146ca9ffdf10eef71c2abf801d2b9a23d06c89341.js integrity="sha256-XBtPzyJIP23ycDuhRsqf/fEO73HCq/gB0rmiPQbIk0E=" defer></script></body></html>